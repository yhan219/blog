<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>shell十三问 - yhan219</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="yhan219的个人博客"><meta name="msapplication-TileImage" content="https://coding-net-production-static-ci.codehub.cn/a79d1f0e-bb39-4be8-afc5-99302615f944.jpg?imageMogr2/auto-orient/format/jpeg/cut/800x800x0x0"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="yhan219的个人博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="我在CU的日子并不长，有幸在shell版上与大家结缘。除了跟众前辈学习到不少技巧之外，也常看到不少朋友的问题。然而，在众多问题中，我发现许多瓶颈都源于shell的基础而已。每次要解说，却总有千言万语不知从何起之感… 这次，我不是来回答，而是准备了关于shell基础的十三个问题要问大家﹗希望shell学习者们能够透过寻找答案的过程，好好的将shell基础打扎实一点…当然了，这些问题我也会逐一解说一遍"><meta property="og:type" content="blog"><meta property="og:title" content="shell十三问"><meta property="og:url" content="https://blog.yhan219.com/shell-13-question/"><meta property="og:site_name" content="yhan219"><meta property="og:description" content="我在CU的日子并不长，有幸在shell版上与大家结缘。除了跟众前辈学习到不少技巧之外，也常看到不少朋友的问题。然而，在众多问题中，我发现许多瓶颈都源于shell的基础而已。每次要解说，却总有千言万语不知从何起之感… 这次，我不是来回答，而是准备了关于shell基础的十三个问题要问大家﹗希望shell学习者们能够透过寻找答案的过程，好好的将shell基础打扎实一点…当然了，这些问题我也会逐一解说一遍"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.yhan219.com/img/og_image.png"><meta property="article:published_time" content="2021-01-13T02:48:58.000Z"><meta property="article:modified_time" content="2021-01-13T02:48:58.000Z"><meta property="article:author" content="網中人"><meta property="article:tag" content="shell"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.yhan219.com/shell-13-question/"},"headline":"yhan219","image":["https://blog.yhan219.com/img/og_image.png"],"datePublished":"2021-01-13T02:48:58.000Z","dateModified":"2021-01-13T02:48:58.000Z","author":{"@type":"Person","name":"網中人"},"description":"我在CU的日子并不长，有幸在shell版上与大家结缘。除了跟众前辈学习到不少技巧之外，也常看到不少朋友的问题。然而，在众多问题中，我发现许多瓶颈都源于shell的基础而已。每次要解说，却总有千言万语不知从何起之感… 这次，我不是来回答，而是准备了关于shell基础的十三个问题要问大家﹗希望shell学习者们能够透过寻找答案的过程，好好的将shell基础打扎实一点…当然了，这些问题我也会逐一解说一遍"}</script><link rel="canonical" href="https://blog.yhan219.com/shell-13-question/"><link rel="icon" href="https://coding-net-production-static-ci.codehub.cn/a79d1f0e-bb39-4be8-afc5-99302615f944.jpg?imageMogr2/auto-orient/format/jpeg/cut/800x800x0x0"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/qtcreator_dark.min.css"><link rel="stylesheet"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?16cea3704e5dd91460340a2925dca9e9";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://coding-net-production-static-ci.codehub.cn/a79d1f0e-bb39-4be8-afc5-99302615f944.jpg?imageMogr2/auto-orient/format/jpeg/cut/800x800x0x0" alt="yhan219" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="yhan219" href="https://github.com/yhan219"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 level is-mobile"><div class="level-left"><div class="article-date level-item"><i class="fa fa-calendar"></i><span>2021-01-13</span></div><span class="level-item"><time dateTime="2021-01-13T02:48:58.000Z" title="2021-01-13T02:48:58.000Z">2021-01-13</time>发表</span><span class="level-item"> <i class="fa fa-user"></i> 網中人 </span><span class="level-item"><i class="fa fa-folder"></i><a class="link-muted" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span><span class="level-item">2 小时读完 (大约21457个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">shell十三问</h1><div class="content"><p>我在CU的日子并不长，有幸在shell版上与大家结缘。除了跟众前辈学习到不少技巧之外，也常看到不少朋友的问题。然而，在众多问题中，我发现许多瓶颈都源于shell的基础而已。每次要解说，却总有千言万语不知从何起之感…</p>
<p>这次，我不是来回答，而是准备了关于shell基础的十三个问题要问大家﹗希望shell学习者们能够透过寻找答案的过程，好好的将shell基础打扎实一点…当然了，这些问题我也会逐一解说一遍。只是，我不敢保证什么时候能够完成这趟任务。除了时间关系外，个人功力实在有限，很怕匆忙间误导观众就糟糕了。若能抛砖引玉，诱得其他前辈出马补充，那才真的是功德一件﹗</p>
<p><escape><a id="more"></a></escape></p>
<h2 id="第1问：为何叫做shell？"><a href="#第1问：为何叫做shell？" class="headerlink" title="第1问：为何叫做shell？"></a>第1问：为何叫做shell？</h2><p>在介绍 <code>shell</code> 是什么东西之前，不妨让我们重新审视使用者与电脑的关系。我们知道电脑的运作不能离开硬件，但使用者却无法直接对硬件作驱动，硬件的驱动只能透过一个称为“操作系统（Operating System）”的软件来控管，事实上，我们每天所谈的linux，严格来说只是一个操作系统，我们称之为“核心（kernel）”。然而，从使用者的角度来说，使用者也没办法直接操作<code>kernel</code>，而是透过<code>kernel</code>的“外壳”程序，也就是所谓的<code>shell</code>，来与<code>kernel</code>沟通。<br>这也正是kernel跟shell的形像命名关系。</p>
<p>从技术角度来说，shell是一个使用者与系统的互动界面（interface），主要是让使用者透过命令行（command line）来使用系统以完成工作。因此，shell的最简单的定义就是—命令解释器（Command Interpreter）：</p>
<ul>
<li>将使用者的命令翻译给核心处理，</li>
<li>同时，将核心处理结果翻译给使用者。</li>
</ul>
<p>每次当我们完成系统登入（log in），我们就取得一个互动模式的shell，也称为login shell或primary shell。若从行程（process）角度来说，我们在shell所下达的命令，均是shell所产生的子行程。这现像，我们暂可称之为fork。如果是执行脚本（shell script）的话，脚本中的命令则是由另外一个非互动模式的子shell（sub shell）来执行的。也就是primary shell产生sub shell的行程，sub shell再产生script中所有命令的行程。（关于行程，我们日后有机会再补充。）</p>
<p>这里，我们必须知道：kernel与shell是不同的两套软件，而且都是可以被替换的：</p>
<ul>
<li>不同的操作系统使用不同的kernel，</li>
<li>而在同一个kernel之上，也可使用不同的shell。</li>
</ul>
<p>在linux的预设系统中，通常都可以找到好几种不同的shell，且通常会被列于如下档案里：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/</span>shells</span><br></pre></td></tr></table></figure>
<p>不同的shell有着不同的功能，且也彼此各异、或说“大同小异”。常见的shell主要分为两大主流：<br>sh：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">burne <span class="keyword">shell</span><span class="bash">（sh）</span></span><br><span class="line">burne again <span class="keyword">shell</span><span class="bash">（bash）</span></span><br></pre></td></tr></table></figure>
<p>csh：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c <span class="keyword">shell</span><span class="bash">（csh）</span></span><br><span class="line">tc <span class="keyword">shell</span><span class="bash">（tcsh）</span></span><br><span class="line">korn <span class="keyword">shell</span><span class="bash">（ksh）</span></span><br></pre></td></tr></table></figure>
<p>大部份的Linux系统的预设shell都是bash，其原因大致如下两点：</p>
<ul>
<li>自由软件</li>
<li>功能强大</li>
</ul>
<p>bash是gnu project最成功的产品之一，自推出以来深受广大Unix用户喜爱，且也逐渐成为不少组织的系统标准。</p>
<h2 id="第2问：shell-prompt（PS1）与-Carriage-Return（CR）的关系？"><a href="#第2问：shell-prompt（PS1）与-Carriage-Return（CR）的关系？" class="headerlink" title="第2问：shell prompt（PS1）与 Carriage Return（CR）的关系？"></a>第2问：shell prompt（PS1）与 Carriage Return（CR）的关系？</h2><p>当你成功登录进一个文字界面之后，大部份情形下，你会在荧幕上看到一个不断闪烁的方块或底线（视不同版本而别），我们称之为<code>游标</code>（cursor）。游标的作用就是告诉你接下来你从键盘输入的按键所插入的位置，且每输入一键游标便向右边移动一个格子，若连续输入太多的话，则自动接在下一行输入。假如你刚完成登录还没输入任何按键之前，你所看到的游标所在位置的同一行的左边部份，我们称之为<code>提示符号</code>（prompt）。提示符号的格式或因不同系统版本而各有不同，在Linux上，只需留意最接近游标的一个可见的提示符号，通常是如下两者之一：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$：</span>给一般使用者帐号使用</span><br><span class="line"><span class="comment">#：给root（管理员）帐号使用</span></span><br></pre></td></tr></table></figure>
<p>事实上，shell prompt的意思很简单：<code>是shell告诉使用者：您现在可以输入命令行了。</code>我们可以说，使用者只有在得到shell prompt才能打命令行，而cursor是指示键盘在命令行所输入的位置，使用者每输入一个键，cursor就往后移动一格，直到碰到命令行读进CR（Carriage Return，由Enter键产生）字符为止。CR的意思也很简单：<code>是使用者告诉shell：老兄你可以执行我的命令了。</code></p>
<p>严格来说：<code>所谓的命令行，就是在shell prompt与CR字符之间所输入的文字。</code>（思考：为何我们这里坚持使用CR字符而不说Enter键呢？答案在后面的学习中揭晓。）不同的命令可接受的命令行格式或有不同，一般情况下，一个标准的命令行格式为如下所列：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">command</span>-name <span class="keyword">options</span> <span class="keyword">argument</span></span><br></pre></td></tr></table></figure>
<p>若从技术细节来看，shell会依据IFS（Internal Field Seperator）将command line所输入的文字给拆解为“字段”（word）。然后再针对特殊字符（meta）先作处理，最后再重组整行command line。（注意：请务必理解上两句话的意思，我们日后的学习中会常回到这里思考。）</p>
<p>其中的IFS是shell预设使用的字段分隔符号，可以由一个及多个如下按键组成：</p>
<ul>
<li>空白键（White Space）</li>
<li>表格键（Tab）</li>
<li>回车键（Enter）</li>
</ul>
<p>系统可接受的命令名称（command-name）可以从如下途径获得：</p>
<ul>
<li>明确路径所指定的外部命令</li>
<li>命令别名（alias）</li>
<li>自定功能（function）</li>
<li>shell内置命令（built-in）</li>
<li>$PATH之下的外部命令</li>
</ul>
<p>每一个命令行均必需含用命令名称，这是不能缺少的。</p>
<h2 id="第3问：别人echo、你也echo，是问echo知多少？"><a href="#第3问：别人echo、你也echo，是问echo知多少？" class="headerlink" title="第3问：别人echo、你也echo，是问echo知多少？"></a>第3问：别人echo、你也echo，是问echo知多少？</h2><p>承接上一章所介绍的command line，这里我们用echo这个命令加以进一步说明。温习—标准的command line包含三个部件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command_name <span class="keyword">option</span> argument</span><br></pre></td></tr></table></figure>
<p>echo是一个非常简单、直接的Linux命令：将argument送出至标准输出（STDOUT），通常就是在显示器（monitor）上输出。（注：stdout我们日后有机会再解说）。为了更好理解，不如先让我们先跑一下echo命令好了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span></span></span><br></pre></td></tr></table></figure>
<p>你会发现只有一个空白行，然后又回到shell prompt上了。这是因为echo在预设上，在显示完argument之后，还会送出一个换行符号（new-line charactor）。但是上面的command并没任何的argument，那结果就只剩一个换行符号了…</p>
<p>若你要取消这个换行符号，可利用echo的-n option：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -n</span></span><br></pre></td></tr></table></figure>
<p>不妨让我们回到command line的概念上来讨论上例的echo命令好了：command line只有command_name（echo）及option（-n），并没有任何argument。</p>
<p>要想看看echo的argument，那还不简单﹗接下来，你可试试如下的输入：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">echo</span> <span class="keyword">first</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">first</span> <span class="built_in">line</span></span><br><span class="line">$ <span class="keyword">echo</span> -n <span class="keyword">first</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">first</span> <span class="built_in">line</span> $</span><br></pre></td></tr></table></figure>
<p>于上两个echo命令中，你会发现argument的部份显示在你的荧幕，而换行符号则视-n option的有无而别。<br>很明显的，第二个echo由于换行符号被取消了，接下来的shell prompt就接在输出结果同一行了…</p>
<p>事实上，echo除了-n options之外，常用选项还有：</p>
<ul>
<li>-e：启用反斜线控制字符的转换（参考下表）</li>
<li>-E：关闭反斜线控制字符的转换（预设如此）</li>
<li>-n：取消行末之换行符号（与-e选项下的\c字符同意）</li>
</ul>
<p>关于echo命令所支持的反斜线控制字符如下表：</p>
<ul>
<li>\a:ALERT / BELL（从系统喇叭送出铃声）</li>
<li>\b:BACKSPACE，也就是向左退格键</li>
<li>\c：取消行末之换行符号</li>
<li>\E:ESCAPE，跳脱键</li>
<li>\f:FORMFEED，分页字符</li>
<li>\n:NEWLINE，换行字符</li>
<li>\r:RETURN，回车键</li>
<li>\t:TAB，表格跳位键</li>
<li>\v:VERTICAL TAB，垂直表格跳位键</li>
<li>\n:ASCII八进位编码（以x开首为十六进位）</li>
<li>\：反斜线本身</li>
</ul>
<p>（表格数据来自O’Reilly出版社之Learning the Bash Shell，2nd Ed.）</p>
<p>或许，我们可以透过实例来了解echo的选项及控制字符：<br>例一：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo -e <span class="string">&quot;a<span class="subst">\t</span>b<span class="subst">\t</span>c<span class="subst">\n</span>d<span class="subst">\t</span>e<span class="subst">\t</span>f&quot;</span></span><br><span class="line">a b c</span><br><span class="line">d e f</span><br></pre></td></tr></table></figure>
<p>上例运用\t来区隔abc还有def，及用\n将def换至下一行。</p>
<p>例二：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo -e &quot;<span class="symbol">\1</span>41<span class="symbol">\0</span>11<span class="symbol">\1</span>42<span class="symbol">\0</span>11<span class="symbol">\1</span>43<span class="symbol">\0</span>12<span class="symbol">\1</span>44<span class="symbol">\0</span>11<span class="symbol">\1</span>45<span class="symbol">\0</span>11<span class="symbol">\1</span>46&quot;</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br></pre></td></tr></table></figure>
<p>与例一的结果一样，只是使用ASCII八进位编码。</p>
<p>例三：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo -e &quot;<span class="symbol">\x</span>61<span class="symbol">\x</span>09<span class="symbol">\x</span>62<span class="symbol">\x</span>09<span class="symbol">\x</span>63<span class="symbol">\x</span>0a<span class="symbol">\x</span>64<span class="symbol">\x</span>09<span class="symbol">\x</span>65<span class="symbol">\x</span>09<span class="symbol">\x</span>66&quot;</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br></pre></td></tr></table></figure>
<p>与例二差不多，只是这次换用ASCII十六进位编码。</p>
<p>例四：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo -ne &quot;a<span class="symbol">\t</span>b<span class="symbol">\t</span>c<span class="symbol">\n</span>d<span class="symbol">\t</span>e<span class="symbol">\b</span>f<span class="symbol">\a</span>&quot;</span><br><span class="line">a b c</span><br><span class="line">d f $</span><br></pre></td></tr></table></figure>
<p>因为e字母后面是退格键（\b），因此输出结果就没有e了。在结束时听到一声铃向，那是\a的杰作﹗<br>由于同时使用了-n选项，因此shell prompt紧接在第二行之后。若你不用-n的话，那你在\a后再加个\c，也是同样的效果。</p>
<p>事实上，在日后的shell操作及shell script设计上，echo命令是最常被使用的命令之一。<br>比方说，用echo来检查变量值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">B</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $？</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>（注：关于变量概念，我们留到下两章才跟大家说明。）<br>好了，更多的关于command line的格式，以及echo命令的选项，就请您自行多加练习、运用了…</p>
<h2 id="第4问：“”（双引号）与’’（单引号）差在哪？"><a href="#第4问：“”（双引号）与’’（单引号）差在哪？" class="headerlink" title="第4问：“”（双引号）与’’（单引号）差在哪？"></a>第4问：“”（双引号）与’’（单引号）差在哪？</h2><p>还是回到我们的command line来吧…</p>
<p>经过前面两章的学习，应该很清楚当你在shell prompt后面敲打键盘、直到按下Enter的时候，<br>你输入的文字就是command line了，然后shell才会以行程的方式执行你所交给它的命令。但是，你又可知道：你在command line输入的每一个文字，对shell来说，是有类别之分的呢？</p>
<p>简单而言（我不敢说这是精确的定议，注一），command line的每一个charactor，分为如下两种：</p>
<ul>
<li>literal：也就是普通纯文字，对shell来说没特殊功能。</li>
<li>meta：对shell来说，具有特定功能的特殊保留字元。（注一：关于bash shell在处理command line时的顺序说明，请参考O’Reilly出版社之Learning the Bash Shell，2nd Edition，第177 - 180页的说明，尤其是178页的流程图Figure 7-1…）</li>
</ul>
<p>Literal没甚么好谈的，凡举abcd、123456这些“文字”都是literal…（easy？）。但meta却常使我们困惑…..（confused？）事实上，前两章我们在command line中已碰到两个机乎每次都会碰到的meta：</p>
<ul>
<li>IFS：由<code>&lt;space&gt;</code>或<code>&lt;tab&gt;</code>或<code>&lt;enter&gt;</code>三者之一组成（我们常用space）。</li>
<li>CR：由<code>&lt;enter&gt;</code>产生。</li>
</ul>
<p>IFS是用来拆解command line的每一个词（word）用的，因为shell command line是按词来处理的。而CR则是用来结束command line用的，这也是为何我们敲<enter>命令就会跑的原因。除了IFS与CR，常用的meta还有：</p>
<ul>
<li>= : 设定变量。</li>
<li>$ : 作变量或运算替换（请不要与shell prompt搞混了）。</li>
<li>&gt; : 重导向stdout。</li>
<li>&lt; : 重导向stdin。</li>
<li>| : 命令管线。</li>
<li>&amp; : 重导向file descriptor，或将命令置于背境执行。</li>
<li>() : 将其内的命令置于nested subshell执行，或用于运算或命令替换。</li>
<li>{} : 将其内的命令置于non-named function中执行，或用在变量替换的界定范围。</li>
<li>; : 在前一个命令结束时，而忽略其返回值，继续执行下一个命令。</li>
<li>&amp;&amp; : 在前一个命令结束时，若返回值为true，继续执行下一个命令。</li>
<li>|| : 在前一个命令结束时，若返回值为false，继续执行下一个命令。</li>
<li>！: 执行history列表中的命令<br>…</li>
</ul>
<p>假如我们需要在command line中将这些保留字元的功能关闭的话，就需要quoting处理了。在bash中，常用的quoting有如下三种方法：</p>
<ul>
<li>hard quote:’ ‘（单引号），凡在hard quote中的所有meta均被关闭。</li>
<li>soft quote:“”（双引号），在soft quote中大部份meta都会被关闭，但某些则保留（如$）。（注二：在soft quote中被豁免的具体meta清单，我不完全知道，有待大家补充，或透过实作来发现及理解。）</li>
<li>escape : \（反斜线），只有紧接在escape（跳脱字符）之后的单一meta才被关闭。</li>
</ul>
<p>下面的例子将有助于我们对quoting的了解：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B C <span class="comment">#空白键未被关掉，作为IFS处理。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> C: <span class="built_in">command</span> not found.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> A=<span class="string">&quot;B C&quot;</span> <span class="comment">#空白键已被关掉，仅作为空白键处理。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">B C</span><br></pre></td></tr></table></figure>
<p>在第一次设定A变量时，由于空白键没被关闭，command line将被解读为：A=B然后碰到<IFS>，再执行C命令</p>
<p>在第二次设定A变量时，由于空白键被置于soft quote中，因此被关闭，不再作为IFS：A=B<space>C</p>
<p>事实上，空白键无论在soft quote还是在hard quote中，均会被关闭。Enter键亦然：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=<span class="string">&#x27;B</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$A</span>&quot;</span></span></span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p>在上例中，由于<enter>被置于hard quote当中，因此不再作为CR字符来处理。这里的<enter>单纯只是一个断行符号（new-line）而已，由于command line并没得到CR字符，因此进入第二个shell prompt（PS2，以&gt;符号表示），command line并不会结束，直到第三行，我们输入的<enter>并不在hard quote里面，因此并没被关闭，此时，command line碰到CR字符，于是结束、交给shell来处理。<br>上例的<enter>要是被置于soft quote中的话，CR也会同样被关闭：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=<span class="string">&quot;B</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="string">&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">B C</span><br></pre></td></tr></table></figure>
<p>然而，由于echo $A时的变量没至于soft quote中，因此当变量替换完成后并作命令行重组时，<enter>会被解释为IFS，而不是解释为New Line字符。</p>
<p>同样的，用<code>escape</code>亦可关闭CR字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ A&#x3D;B\</span><br><span class="line">&gt; C\</span><br><span class="line">&gt;</span><br><span class="line">$ echo $A</span><br><span class="line">BC</span><br></pre></td></tr></table></figure>
<p>上例中，第一个<enter>跟第二个<enter>均被<code>escape</code>字符关闭了，因此也不作为CR来处理，<br>但第三个<enter>由于没被跳脱，因此作为CR结束command line。</p>
<p>但由于<enter>键本身在shell meta中的特殊性，在\跳脱后面，仅仅取消其CR功能，而不会保留其IFS功能。</p>
<p>您或许发现光是一个<enter>键所产生的字符就有可能是如下这些可能：<code>CR</code>、<code>IFS</code>、<code>NL（New Line）</code>、<code>FF（Form Feed）</code>、<code>NULL</code> …至于什么时候会解释为什么字符，这个我就没去深挖了，或是留给读者诸君自行慢慢摸索了…</p>
<p>至于soft quote跟hard quote的不同，主要是对于某些meta的关闭与否，以$来作说明：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B\ C</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$A</span>&quot;</span></span></span><br><span class="line">B C</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;$A&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">A</span></span><br></pre></td></tr></table></figure>
<p>在第一个echo命令行中，$被置于soft quote中，将不被关闭，因此继续处理变量替换，因此echo将A的变量值输出到荧幕，也就得到<code>B C</code>的结果。在第二个echo命令行中，被置于hard quote中，则被关闭，因此被置于<em>hardquote</em>中，则被关闭，因此只是一个符号，并不会用来作变量替换处理，因此结果是符号，并不会用来作变量替换处理，因此结果是符号后面接一个A字母：$A。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 练习与思考：如下结果为何不同？</span></span><br><span class="line"><span class="variable">$</span> A=B\ C</span><br><span class="line"><span class="variable">$</span> <span class="built_in">echo</span> <span class="string">&#x27;&quot;$A&quot;&#x27;</span> <span class="comment">#最外面的是单引号</span></span><br><span class="line"><span class="string">&quot;<span class="variable">$A</span>&quot;</span></span><br><span class="line"><span class="variable">$</span> <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$A</span>&#x27;&quot;</span> <span class="comment">#最外面的是双引号</span></span><br><span class="line"><span class="string">&#x27;B C&#x27;</span></span><br><span class="line">（提示：单引号及双引号，在quoting中均被关闭了。）</span><br></pre></td></tr></table></figure>
<p>在CU的shell版里，我发现有很多初学者的问题，都与quoting理解的有关。比方说，若我们在awk或sed的命令参数中调用之前设定的一些变量时，常会问及为何不能的问题。要解决这些问题，关键点就是：<br><code>区分出shell meta与command meta</code></p>
<p>前面我们提到的那些meta，都是在command line中有特殊用途的，比方说{ }是将其内一系列command line置于不具名的函式中执行（可简单视为command block），但是，awk却需要用{ }来区分出awk的命令区段（BEGIN，MAIN，END）。若你在command line中如此输入：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#123;<span class="builtin-name">print</span> <span class="variable">$0</span>&#125; 1.txt</span><br></pre></td></tr></table></figure>
<p>由于<code>&#123; &#125;</code>在shell中并没关闭，那shell就将<code>&#123;print $0&#125;</code>视为command block，但同时又没有<code>;</code>符号作命令区隔，因此就出现awk的语法错误结果。要解决之，可用hard quote：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;print <span class="subst">$0</span>&#125;&#x27;</span> <span class="number">1.</span>txt</span><br></pre></td></tr></table></figure>
<p>上面的hard quote应好理解，就是将原本的<code>&#123;</code>、<code>&lt;space&gt;</code>、<code>$</code>（注三）、<code>&#125;</code>这几个shell meta关闭，避免掉在shell中遭到处理，而完整的成为awk参数中的command meta。（注三：而其中的0是awk内置的field number，而非awk的变量，awk自身的变量无需使用0是<em>awk</em>内置的<em>fieldnumber</em>，而非<em>awk</em>的变量，<em>awk</em>自身的变量无需使用。）</p>
<p>要是理解了hard quote的功能，再来理解soft quote与escape就不难：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk &quot;&#123;print <span class="symbol">\$</span>0&#125;&quot; 1.txt</span><br><span class="line">awk <span class="symbol">\&#123;</span>print<span class="symbol">\ </span><span class="symbol">\$</span>0<span class="symbol">\&#125;</span> 1.txt</span><br></pre></td></tr></table></figure>
<p>然而，若你要改变awk的0的0值是从另一个shell变量读进呢？比方说：已有变量0的0值是从另一个<em>shell</em>变量读进呢？比方说：已有变量A的值是0，那如何在command line中解决awk的<code>$$A</code>呢？你可以很直接否定掉hard quoe的方案：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;&#123;<span class="keyword">print</span> <span class="built_in">$$A</span>&#125;&#x27; <span class="number">1.</span>txt</span><br></pre></td></tr></table></figure>
<p>那是因为A的<em>A</em>的在hard quote中是不能替换变量的。聪明的读者（如你！），经过本章学习，我想，应该可以解释为何我们可以使用如下操作了吧：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="number">0</span></span><br><span class="line">awk <span class="string">&quot;&#123;print \$<span class="subst">$A</span>&#125;&quot;</span> <span class="number">1.</span>txt</span><br><span class="line">awk \&#123;<span class="keyword">print</span>\ \<span class="variable">$$A</span>\&#125; <span class="number">1.</span>txt</span><br><span class="line">awk <span class="string">&#x27;&#123;print $&#x27;</span><span class="variable">$A</span><span class="string">&#x27;&#125;&#x27;</span> <span class="number">1.</span>txt</span><br><span class="line">awk <span class="string">&#x27;&#123;print $&#x27;</span><span class="string">&quot;<span class="subst">$A</span>&quot;</span><span class="string">&#x27;&#125;&#x27;</span> <span class="number">1.</span>txt <span class="comment">#注：“$A”包在soft quote中</span></span><br></pre></td></tr></table></figure>
<p>或许，你能举出更多的方案呢….</p>
<p>练习与思考：请运用本章学到的知识分析如下两串讨论：<br><a target="_blank" rel="noopener" href="http://bbs.chinaunix.net/forum/viewtopic.php?t=207178">http://bbs.chinaunix.net/forum/viewtopic.php?t=207178</a><br><a target="_blank" rel="noopener" href="http://bbs.chinaunix.net/forum/viewtopic.php?t=207178">http://bbs.chinaunix.net/forum/viewtopic.php?t=207178</a></p>
<h2 id="第5问：var-value-export前后差在哪"><a href="#第5问：var-value-export前后差在哪" class="headerlink" title="第5问：var=value? export前后差在哪?"></a>第5问：var=value? export前后差在哪?</h2><p>这次让我们暂时丢开command line，先来了解一下bash变量（variable）吧…</p>
<p>所谓的变量，就是利用一个特定的“名称”（name）来存取一段可以变化的“值”（value）。</p>
<h3 id="设定（set）"><a href="#设定（set）" class="headerlink" title="设定（set）"></a>设定（set）</h3><p>在bash中，你可以用“=”来设定或重新定义变量的内容：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span>=value</span><br></pre></td></tr></table></figure>
<p>在设定变量的时侯，得遵守如下规则：</p>
<ul>
<li>等号左右两边不能使用区隔符号（IFS），也应避免使用shell的保留字元（meta charactor）。</li>
<li>变量名称不能使用$符号。</li>
<li>变量名称的第一个字母不能是数字（number）。</li>
<li>变量名称长度不可超过256个字母。</li>
<li>变量名称及变量值之大小写是有区别的（case sensitive）。</li>
</ul>
<p>如下是一些变量设定时常见的错误：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A= <span class="keyword">B </span><span class="comment"># 不能有IFS</span></span><br><span class="line"><span class="number">1</span>A=<span class="keyword">B </span><span class="comment"># 不能以数字开头</span></span><br><span class="line">$A=<span class="keyword">B </span><span class="comment"># 名称不能有$</span></span><br><span class="line">a=<span class="keyword">B </span><span class="comment"># 这跟a=b是不同的（这不是错误，提醒windows的使用者要特别注意）</span></span><br></pre></td></tr></table></figure>
<p>如下则是可以接受的设定：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A</span>=<span class="string">&quot; B&quot;</span> <span class="comment"># IFS被关闭了（请参考前面的quoting章节）</span></span><br><span class="line"><span class="attr">A1</span>=B <span class="comment"># 并非以数字开头</span></span><br><span class="line"><span class="attr">A</span>=<span class="variable">$B</span> <span class="comment"># $可用在变量值内</span></span><br><span class="line"><span class="attr">This_Is_A_Long_Name</span>=b <span class="comment">#可用_连接较长的名称或值，且大小写有别。</span></span><br></pre></td></tr></table></figure>
<h3 id="变量替换（substitution）"><a href="#变量替换（substitution）" class="headerlink" title="变量替换（substitution）"></a>变量替换（substitution）</h3><p>Shell之所以强大，其中的一个因素是它可以在命令行中对变量作替换（substitution）处理。<br>在命令行中使用者可以使用$符号加上变量名称（除了在用=号定义变量名称之外），<br>将变量值给替换出来，然后再重新组建命令行。<br>比方：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">A</span>=ls</span><br><span class="line">$ <span class="attribute">B</span>=la</span><br><span class="line">$ <span class="attribute">C</span>=/tmp</span><br><span class="line">$ <span class="variable">$A</span> -<span class="variable">$B</span> <span class="variable">$C</span></span><br></pre></td></tr></table></figure>
<p>（注意：以上命令行的第一个$是shell prompt，并不在命令行之内。）</p>
<p>必需强调的是，我们所提的变量替换，只发生在command line上面。（是的，让我们再回到command line吧﹗）仔细分析最后那行command line，不难发现在被执行之前（在输入CR字符之前），<br>$符号会对每一个变量作替换处理（将变量值替换出来再重组命令行），最后会得出如下命令行：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -la <span class="string">/tmp</span></span><br></pre></td></tr></table></figure>
<p>还记得第二章我请大家“务必理解”的那两句吗？若你忘了，那我这里再重贴一遍：<br>若从技术细节来看，shell会依据IFS（Internal Field Seperator）将command line所输入的文字给拆解为“字段”（word）。然后再针对特殊字符（meta）先作处理，最后再重组整行command line。这里的$就是command line中最经典的meta之一了，就是作变量替换的﹗</p>
<p>在日常的shell操作中，我们常会使用echo命令来查看特定变量的值，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span> -<span class="variable">$B</span> <span class="variable">$C</span></span></span><br></pre></td></tr></table></figure>
<p>我们已学过，echo命令只单纯将其argument送至“标准输出”（STDOUT，通常是我们的荧幕）。<br>所以上面的命令会在荧幕上得到如下结果：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -la <span class="string">/tmp</span></span><br></pre></td></tr></table></figure>
<p>这是由于echo命令在执行时，会先将A（ls）、<em>A</em>（<em>ls</em>）、B（la）、跟$C（/tmp）给替换出来的结果。<br>利用shell对变量的替换处理能力，我们在设定变量时就更为灵活了：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A</span>=B</span><br><span class="line"><span class="attr">B</span>=<span class="variable">$A</span></span><br></pre></td></tr></table></figure>
<p>这样，B的变量值就可继承A变量“当时”的变量值了。不过，不要以“数学逻辑”来套用变量的设定，比方说：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A</span>=B</span><br><span class="line"><span class="attr">B</span>=C</span><br></pre></td></tr></table></figure>
<p>这样并不会让A的变量值变成C。再如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A</span>=B</span><br><span class="line"><span class="attr">B</span>=<span class="variable">$A</span></span><br><span class="line"><span class="attr">A</span>=C</span><br></pre></td></tr></table></figure>
<p>同样也不会让B的值换成C。上面是单纯定义了两个不同名称的变量：A与B，它们的值分别是B与C。</p>
<p>若变量被重复定义的话，则原有旧值将被新值所取代。（这不正是“可变的量”吗？）</p>
<p>当我们在设定变量的时侯，请记着这点：用一个名称储存一个数值，仅此而已。此外，我们也可利用命令行的变量替换能力来“扩充”（append）变量值：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A</span>=B:C:D</span><br><span class="line"><span class="attr">A</span>=<span class="variable">$A</span>:E</span><br></pre></td></tr></table></figure>
<p>这样，第一行我们设定A的值为“B:C:D”，然后，第二行再将值扩充为“B:C:D:E”。<br>上面的扩充示例，我们使用区隔符号（：）来达到扩充目的，要是没有区隔符号的话，如下是有问题的：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A</span>=BCD</span><br><span class="line"><span class="attr">A</span>=<span class="variable">$AE</span></span><br></pre></td></tr></table></figure>
<p>因为第二次是将A的值继承AE的提换结果，而非<em>AE</em>的提换结果，而非A再加E！要解决此问题，我们可用更严谨的替换处理：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A</span>=BCD</span><br><span class="line"><span class="attr">A</span>=<span class="variable">$&#123;A&#125;</span>E</span><br></pre></td></tr></table></figure>
<p>上例中，我们使用{}将变量名称的范围给明确定义出来，如此一来，我们就可以将A的变量值从BCD给扩充为BCDE。（提示：关于${name}事实上还可做到更多的变量处理能力，这些均属于比较进阶的变量处理，<br>现阶段暂时不介绍了，请大家自行参考资料。如CU的贴子：<a target="_blank" rel="noopener" href="http://www.chinaunix.net/forum/viewtopic.php?t=201843">http://www.chinaunix.net/forum/viewtopic.php?t=201843</a></p>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>严格来说，我们在当前shell中所定义的变量，均属于“本地变量”（local variable），只有经过export命令的“输出”处理，才能成为环境变量（environment variable）：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">A</span>=B</span><br><span class="line">$ <span class="builtin-name">export</span> A</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="builtin-name">export</span> <span class="attribute">A</span>=B</span><br></pre></td></tr></table></figure>
<p>经过export输出处理之后，变量A就能成为一个环境变量供其后的命令使用。在使用export的时侯，请别忘记shell在命令行对变量的“替换”（substitution）处理，比方说：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">A</span>=B</span><br><span class="line">$ <span class="attribute">B</span>=C</span><br><span class="line">$ <span class="builtin-name">export</span> <span class="variable">$A</span></span><br></pre></td></tr></table></figure>
<p>上面的命令并未将A输出为环境变量，而是将B作输出，这是因为在这个命令行中，$A会首先被替换为B，然后再“塞回”作export的参数。要理解这个export，事实上需要从process的角度来理解才能透彻。我将于下一章为大家说明process的观念，敬请留意。</p>
<h3 id="取消变量"><a href="#取消变量" class="headerlink" title="取消变量"></a>取消变量</h3><p>要取消一个变量，在bash中可使用unset命令来处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> A</span><br></pre></td></tr></table></figure>
<p>与export一样，unset命令行也同样会作变量替换（这其实就是shell的功能之一），因此：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">A</span>=B</span><br><span class="line">$ <span class="attribute">B</span>=C</span><br><span class="line">$ unset <span class="variable">$A</span></span><br></pre></td></tr></table></figure>
<p>事实上所取消的变量是B而不是A。</p>
<p>此外，变量一旦经过<code>unset</code>取消之后，其结果是将整个变量拿掉，而不仅是取消其变量值。<br>如下两行其实是很不一样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br></pre></td></tr></table></figure>
<p>第一行只是将变量A设定为“空值”（null value），但第二行则让变量A不在存在。<br>虽然用眼睛来看，这两种变量状态在如下命令结果中都是一样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br></pre></td></tr></table></figure>
<p>请学员务必能识别<code>null value</code>与<code>unset</code>的本质区别，这在一些进阶的变量处理上是很严格的。比方说：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> str= <span class="comment">#设为null</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> var=<span class="variable">$&#123;str=expr&#125;</span> <span class="comment">#定义var</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$str</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> str <span class="comment">#取消</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> var=<span class="variable">$&#123;str=expr&#125;</span> <span class="comment">#定义var</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line">expr</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$str</span></span></span><br><span class="line">expr</span><br></pre></td></tr></table></figure>
<p>聪明的读者（yes，you！），稍加思考的话，应该不难发现为何同样的var=${str=expr}在null与unset之下的不同吧？若你看不出来，那可能是如下原因之一：</p>
<ol>
<li>你太笨了</li>
<li>不了解var=${str=expr}这个进阶处理</li>
<li>对本篇说明还没来得及消化吸收</li>
<li>我讲得不好</li>
</ol>
<p>不知，你选哪个呢？…. 嗯… 好吧，我就解釋一下 var=${str=expr} ：</p>
<p>首先，var=str 這個大家都可理解吧。而接下來的思考方向是，究竟<em>str</em>這個大家都可理解吧。而接下來的思考方向是，究竟str 這個變量是如下哪一種情況呢：</p>
<ol>
<li>unset</li>
<li>null</li>
<li>not null</li>
</ol>
<p>假如是 unset ，那麼 var=${str=expr} 的結果將是：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">var</span>=expr</span><br><span class="line"><span class="attr">str</span>=expr</span><br></pre></td></tr></table></figure>
<p>假如是 null ，那 var=${str=expr} 的結果是：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var</span>=</span><br><span class="line"><span class="attribute">str</span>=</span><br></pre></td></tr></table></figure>
<p>假如是 not null (比方為 xyz )，那 var=${str=expr} 之結果是：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">var</span>=xyz</span><br><span class="line"><span class="attr">str</span>=xyz</span><br></pre></td></tr></table></figure>
<h2 id="第6问：exec跟source差在哪？"><a href="#第6问：exec跟source差在哪？" class="headerlink" title="第6问：exec跟source差在哪？"></a>第6问：exec跟source差在哪？</h2><p>这次先让我们从CU Shell版的一个实例贴子来谈起吧：（论坛改版后原连接已经失效）例中的提问原文如下：</p>
<blockquote>
<p>cd /etc/aa/bb/cc 可以执行，但是把这条命令写入shell时shell不执行！这是什么原因呀！（意思是：运行脚本后并没有移到/etc/aa/bb/cc目录）</p>
</blockquote>
<p>我当时如何回答暂时别去深究，先让我们了解一下行程（process）的观念好了。首先，我们所执行的任何程序，都是由父行程（parent process）所产生出来的一个子行程（child process），子行程在结束后，将返回到父行程去。此一现像在Linux系统中被称为fork。（为何要程为fork呢？嗯，画一下图或许比较好理解…）</p>
<p>当子行程被产生的时候，将会从父行程那里获得一定的资源分配、及（更重要的是）继承父行程的环境﹗让我们回到上一章所谈到的“环境变量”吧：</p>
<blockquote>
<p>所谓环境变量其实就是那些会传给子行程的变量。简单而言，“遗传性”就是区分本地变量与环境变量的决定性指标。</p>
</blockquote>
<p>然而，从遗传的角度来看，我们也不难发现环境变量的另一个重要特征：</p>
<blockquote>
<p>环境变量只能从父行程到子行程单向继承。换句话说：在子行程中的环境如何变更，均不会影响父行程的环境。</p>
</blockquote>
<p>接下来，再让我们了解一下命令脚本（shell script）的概念。所谓的<code>shell script</code>讲起来很简单，就是将你平时在shell prompt后所输入的多行command line依序写入一个文件去而已。其中再加上一些条件判断、互动界面、参数运用、函数调用等等技巧，得以让script更加“聪明”的执行，但若撇开这些技巧不谈，我们真的可以简单的看成script只不过依次执行预先写好的命令行而已。</p>
<p>再结合以上两个概念（process + script），那应该就不难理解如下这句话的意思了：</p>
<blockquote>
<p>正常来说，当我们执行一个shell script时，其实是先产生一个sub-shell的子行程，然后sub-shell再去产生命令行的子行程。</p>
</blockquote>
<p>然则，那让我们回到本章开始时所提到的例子再从新思考：<code>cd /etc/aa/bb/cc</code>可以执行，但是把这条命令写入shell时shell不执行！这是什么原因呀！我当时的答案是这样的：</p>
<blockquote>
<p>因为，一般我们跑的shell script是用subshell去执行的。从process的观念来看，是parent process产生一个child process去执行，当child结束后，会返回parent，但parent的环境是不会因child的改变而改变的。所谓的环境元数很多，凡举effective id，variable，workding dir等等…其中的workding dir（PWD）正是楼主的疑问所在：当用subshell来跑script的话，sub shell的<em>PWD</em>）正是楼主的疑问所在：当用<em>subshell</em>来跑<em>script</em>的话，<em>subshell</em>的PWD会因为cd而变更，但当返回primary shell时，$PWD是不会变更的。</p>
</blockquote>
<p>能够了解问题的原因及其原理是很好的，但是？如何解决问题恐怕是我们更感兴趣的﹗是吧？</p>
<p>那好，接下来，再让我们了解一下<code>source</code>命令好了。当你有了fork的概念之后，要理解source就不难：</p>
<blockquote>
<p>所谓source就是让script在当前shell内执行、而不是产生一个sub-shell来执行。</p>
</blockquote>
<p>由于所有执行结果均于当前shell内完成，若script的环境有所改变，当然也会改变当前环境了﹗因此，只要我们将原本单独输入的script命令行变成source命令的参数，就可轻易解决前例提到的问题了。</p>
<p>比方说，原本我们是如此执行script的：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="keyword">my</span>.<span class="keyword">script</span></span><br></pre></td></tr></table></figure>
<p>现在改成这样即可：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ./<span class="keyword">my</span>.<span class="keyword">script</span></span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../<span class="keyword">my</span>.<span class="keyword">script</span></span><br></pre></td></tr></table></figure>
<p>说到这里，我想，各位有兴趣看看/etc底下的众多设定文件，应该不难理解它们被定义后，如何让其他script读取并继承了吧？若然，日后你有机会写自己的script，应也不难专门指定一个设定文件以供不同的script一起“共享”了…</p>
<p>okay，到这里，若你搞得懂fork与source的不同，那接下来再接受一个挑战：</p>
<p>那<code>exec</code>又与source/fork有何不同呢？</p>
<p>哦…要了解<code>exec</code>或许较为复杂，尤其扯上File Descriptor的话…不过，简单来说：</p>
<blockquote>
<p>exec也是让script在同一个行程上执行，但是原有行程则被结束了。也就是简而言之：原有行程会否终止，就是exec与source/fork的最大差异了。</p>
</blockquote>
<p>嗯，光是从理论去理解，或许没那么好消化，不如动手“实作+思考”来的印象深刻哦。下面让我们写两个简单的script，分别命名为1.sh及2.sh：</p>
<p>1.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">A=B</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PID for 1.sh before exec/source/fork:$$&quot;</span></span><br><span class="line"><span class="built_in">export</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1.sh: \$A is <span class="variable">$A</span>&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">exec</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;using exec…&quot;</span></span><br><span class="line">        <span class="built_in">exec</span> ./2.sh;;</span><br><span class="line">    <span class="built_in">source</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;using source…&quot;</span></span><br><span class="line">        ../2.sh;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;using fork by default…&quot;</span></span><br><span class="line">        ./2.sh;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PID for 1.sh after exec/source/fork:$$&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1.sh: \$A is <span class="variable">$A</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>2.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PID for 2.sh: $$&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2.sh get \$A=<span class="variable">$A</span> from 1.sh&quot;</span></span><br><span class="line">A=C</span><br><span class="line"><span class="built_in">export</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2.sh: \$A is <span class="variable">$A</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后，分别跑如下参数来观察结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./1.sh fork</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./1.sh <span class="built_in">source</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./1.sh <span class="built_in">exec</span></span></span><br></pre></td></tr></table></figure>
<p>好了，别忘了仔细比较输出结果的不同及背后的原因哦…若有疑问，欢迎提出来一起讨论讨论</p>
<p>happy scripting！</p>
<h2 id="第7问：-与-差在哪？"><a href="#第7问：-与-差在哪？" class="headerlink" title="第7问：( ) 与 { } 差在哪？"></a>第7问：( ) 与 { } 差在哪？</h2><p>嗯，这次轻松一下，不讲太多…</p>
<p>先说一下，为何要用（）或{ }好了。许多时候，我们在shell操作上，需要在一定条件下一次执行多个命令，也就是说，要么不执行，要么就全执行，而不是每次依序的判断是否要执行下一个命令。或是，需要从一些命令执行优先次顺中得到豁免，如算术的2*（3+4）那样…</p>
<p>这时候，我们就可引入“命令群组”（command group）的概念：将多个命令集中处理。在shell command line中，一般人或许不太计较（）与{ }这两对符号的差异，虽然两者都可将多个命令作群组化处理，但若从技术细节上，却是很不一样的：</p>
<ul>
<li>( ) 将command group置于sub-shell去执行，也称nested sub-shell。</li>
<li>{ } 则是在同一个shell内完成，也称为non-named command group。</li>
</ul>
<p>若，你对上一章的fork与source的概念还记得了的话，那就不难理解两者的差异了。</p>
<p>要是在command group中扯上变量及其他环境的修改，我们可以根据不同的需求来使用（）或{ }。</p>
<p>通常而言，若所作的修改是临时的，且不想影响原有或以后的设定，那我们就nested sub-shell，反之，则用non-named command group。</p>
<p>是的，光从command line来看，()与{}的差别就讲完了，够轻松吧<br>然而，若这两个meta用在其他command meta或领域中（如Regular Expression），还是有很多差别的。只是，我不打算再去说明了，留给读者自己慢慢发掘好了…我这里只想补充一个概念，就是<code>function</code>。<br>所谓的<code>function</code>，就是用一个名字去命名一个command group，然后再调用这个名字去执行command group。从non-named command group来推断，大概你也可以猜到我要说的是{ }了吧？（yes！你真聪明﹗）</p>
<p>在bash中，function的定义方式有两种：<br>方式一：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function function_name &#123;</span><br><span class="line"><span class="keyword">command</span>1</span><br><span class="line"><span class="keyword">command</span>2</span><br><span class="line"><span class="keyword">command</span>3</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fuction_name<span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">command</span>1</span><br><span class="line"><span class="keyword">command</span>2</span><br><span class="line"><span class="keyword">command</span>3</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用哪一种方式无所谓，只是若碰到所定意的名称与现有的命令或别名（Alias）冲突的话，方式二或许会失败。但方式二起码可以少打function这一串英文字母，对懒人来说（如我），又何乐不为呢？…</p>
<p>function在某一程度来说，也可称为“函式”，但请不要与传统编程所使用的函式（library）搞混了，毕竟两者差异很大。惟一相同的是，我们都可以随时用“已定义的名称”来调用它们…</p>
<p>若我们在shell操作中，需要不断的重覆执行某些命令，我们首先想到的，或许是将命令写成命令脚本（shell script）。不过，我们也可以写成function，然后在command line中打上<code>function_name</code>就可当一舨的script来使用了。</p>
<p>只是若你在shell中定义的<code>function</code>，除了可用<code>unset function_name</code>取消外，一旦退出shell，function也跟着取消。</p>
<p>然而，在script中使用function却有许多好处，除了可以提高整体script的执行性能外（因为已被加载），还可以节省许多重覆的代码…</p>
<p>简单而言，若你会将多个命令写成script以供调用的话，那，你可以将function看成是script中的script…</p>
<p>而且，透过上一章介绍的<code>source</code>命令，我们可以自行定义许许多多好用的function，再集中写在特定文件中，然后，在其他的script中用source将它们加载并反复执行。</p>
<p>若你是RedHat Linux的使用者，或许，已经猜得出<code>/etc/rc.d/init.d/functions</code>这个文件是作啥用的了</p>
<p>okay，说要轻松点的嘛，那这次就暂时写到这吧。祝大家学习愉快﹗</p>
<h2 id="第8问：-与-与-还有-差在哪？"><a href="#第8问：-与-与-还有-差在哪？" class="headerlink" title="第8问：(( )) 与(())与( ) 还有${ } 差在哪？"></a>第8问：(( )) 与(())与( ) 还有${ } 差在哪？</h2><p>我们上一章介绍了( )与{ }的不同，这次让我们扩展一下，看看更多的变化：（）与（）与{ }又是啥玩意儿呢？</p>
<p>在bash shell中，<code>$()</code> 与<code> </code>（反引号）都是用来做命令替换用（command substitution）的。所谓的命令替换与我们第五章学过的变量替换差不多，都是用来重组命令行：</p>
<blockquote>
<p>完成引号里的命令行，然后将其结果替换出来，再重组命令行。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo the last sunday is $(<span class="keyword">date</span> -d <span class="string">&quot;last sunday&quot;</span> +%Y-%m-%d)</span><br></pre></td></tr></table></figure>
<p>如此便可方便得到上一星期天的日期了…</p>
<p>在操作上，用<code>$()</code>或<code> </code>都无所谓，只是我”个人”比较喜欢用<code>$()</code>，理由是：</p>
<ol>
<li><code> </code>很容易与’ ‘（单引号）搞混乱，尤其对初学者来说。有时在一些奇怪的字形显示中，两种符号是一模一样的（直竖两点）。当然了，有经验的朋友还是一眼就能分辩两者。只是，若能更好的避免混乱，又何乐不为呢？</li>
<li>在多层次的复合替换中，<code> </code>须要额外的跳脱（`）处理，而<code>$()</code> 则比较直观。例如：这是错的：</li>
</ol>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 `command2 `command3` `</span><br></pre></td></tr></table></figure>
<p>原本的意图是要在command2 <code>command3</code>先将command3提换出来给command2处理，然后再将结果传给command1 <code>command2…</code>来处理。然而，真正的结果在命令行中却是分成了<code>command2</code>与<code> </code>两段。正确的输入应该如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 `command2 \`command3\` `</span><br></pre></td></tr></table></figure>
<p>要不然，换成<code>$()</code>就没问题了：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 <span class="constructor">$(<span class="params">command2</span> $(<span class="params">command3</span>)</span>)</span><br></pre></td></tr></table></figure>
<p>只要你喜欢，做多少层的替换都没问题啦</p>
<p>不过，<code>$()</code>并不是没有斃端的…</p>
<p>首先，``基本上可用在全部的unix shell中使用，若写成shell script，其移植性比较高。而<code>$()</code>并不见的每一种shell都能使用，我只能跟你说，若你用<code>bash2</code>的话，肯定没问题…</p>
<p>接下来，再让我们看<code>$&#123;&#125;</code>吧…它其实就是用来作变量替换用的啦。一般情况下，<code>$var</code>与<code>$&#123;var&#125;</code>并没有啥不一样。但是用<code>$&#123;&#125;</code>会比较精确的界定变量名称的范围，比方说：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$AB</span></span></span><br></pre></td></tr></table></figure>
<p>原本是打算先将$A的结果替换出来，然后再补一个B字母于其后，但在命令行上，真正的结果却是只会提换变量名称为AB的值出来…若使用<code>$&#123;&#125;</code>就没问题了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;A&#125;</span>B</span></span><br><span class="line">BB</span><br></pre></td></tr></table></figure>
<p>不过，假如你只看到<code>$&#123;&#125;</code>只能用来界定变量名称的话，那你就实在太小看bash了﹗为了完整起见，我这里再用一些例子加以说明<code>$&#123;&#125;</code>的一些特异功能。</p>
<p>假设我们定义了一个变量为：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>=<span class="regexp">/dir1/</span>dir2<span class="regexp">/dir3/my</span>.<span class="keyword">file</span>.txt</span><br></pre></td></tr></table></figure>
<p>我们可以用<code>$&#123;&#125;</code>分别替换获得不同的值：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="built_in">file</span><span class="comment">#*/&#125; # 拿掉第一条/及其左边的字串：dir1/dir2/dir3/my.file.txt</span></span><br><span class="line">$&#123;<span class="built_in">file</span><span class="comment">##*/&#125; # 拿掉最后一条/及其左边的字串：my.file.txt</span></span><br><span class="line">$&#123;<span class="built_in">file</span><span class="comment">#*.&#125; # 拿掉第一个.及其左边的字串：file.txt</span></span><br><span class="line">$&#123;<span class="built_in">file</span><span class="comment">##*.&#125; # 拿掉最后一个.及其左边的字串：txt</span></span><br><span class="line">$&#123;<span class="built_in">file</span>%/*&#125; <span class="comment"># 拿掉最后条/及其右边的字串：/dir1/dir2/dir3</span></span><br><span class="line">$&#123;<span class="built_in">file</span>%%/*&#125; <span class="comment"># 拿掉第一条/及其右边的字串：（空值）</span></span><br><span class="line">$&#123;<span class="built_in">file</span>%.*&#125; <span class="comment"># 拿掉最后一个.及其右边的字串：/dir1/dir2/dir3/my.file</span></span><br><span class="line">$&#123;<span class="built_in">file</span>%%.*&#125; <span class="comment">#拿掉第一个.及其右边的字串：/dir1/dir2/dir3/my</span></span><br></pre></td></tr></table></figure>
<p>记忆的方法为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 是去掉左边（在键盘上<span class="comment">#在$之左边）</span></span></span><br><span class="line"><span class="meta">%</span><span class="bash"> 是去掉右边（在键盘上%在$之右边）</span></span><br><span class="line">单一符号是最小匹配,两个符号是最大匹配。</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;file:0:5&#125; <span class="comment"># 提取最左边的5个字节：/dir1</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;file:5:5&#125; <span class="comment"># 提取第5个字节右边的连续5个字节：/dir2</span></span></span><br></pre></td></tr></table></figure>
<p>我们也可以对变量值里的字串作替换：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="keyword">file</span><span class="regexp">/dir/</span>path&#125; # 将第一个dir提换为path:<span class="regexp">/path1/</span>dir2<span class="regexp">/dir3/my</span>.<span class="keyword">file</span>.txt</span><br><span class="line">$&#123;<span class="keyword">file</span><span class="comment">//dir/path&#125; # 将全部dir提换为path:/path1/path2/path3/my.file.txt</span></span><br></pre></td></tr></table></figure>
<p>利用<code>$&#123;&#125;</code>还可针对不同的变数状态赋值（没设定、空值、非空值）</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span>&#123;<span class="keyword">file</span>-my.<span class="keyword">file</span>.txt&#125;    # 假如<span class="symbol">$</span><span class="keyword">file</span>没有设定，则使用my.<span class="keyword">file</span>.txt作传回值。（空值及非空值时不作处理）</span><br><span class="line"><span class="symbol">$</span>&#123;<span class="keyword">file</span>:-my.<span class="keyword">file</span>.txt&#125;   # 假如<span class="symbol">$</span><span class="keyword">file</span>没有设定或为空值，则使用my.<span class="keyword">file</span>.txt作传回值。（非空值时不作处理）</span><br><span class="line"><span class="symbol">$</span>&#123;<span class="keyword">file</span>+my.<span class="keyword">file</span>.txt&#125;    # 假如<span class="symbol">$</span><span class="keyword">file</span>设为空值或非空值，均使用my.<span class="keyword">file</span>.txt作传回值。（没设定时不作处理）</span><br><span class="line"><span class="symbol">$</span>&#123;<span class="keyword">file</span>:+my.<span class="keyword">file</span>.txt&#125;   # 若<span class="symbol">$</span><span class="keyword">file</span>为非空值，则使用my.<span class="keyword">file</span>.txt作传回值。（没设定及空值时不作处理）</span><br><span class="line"><span class="symbol">$</span>&#123;<span class="keyword">file</span>=my.<span class="keyword">file</span>.txt&#125;    # 若<span class="symbol">$</span><span class="keyword">file</span>没设定，则使用my.<span class="keyword">file</span>.txt作传回值，同时将<span class="symbol">$</span><span class="keyword">file</span>赋值为my.<span class="keyword">file</span>.txt。（空值及非空值时不作处理）</span><br><span class="line"><span class="symbol">$</span>&#123;<span class="keyword">file</span>:=my.<span class="keyword">file</span>.txt&#125;   # 若<span class="symbol">$</span><span class="keyword">file</span>没设定或为空值，则使用my.<span class="keyword">file</span>.txt作传回值，同时将<span class="symbol">$</span><span class="keyword">file</span>赋值为my.<span class="keyword">file</span>.txt。（非空值时不作处理）</span><br><span class="line"><span class="symbol">$</span>&#123;<span class="keyword">file</span>?my.<span class="keyword">file</span>.txt&#125;    # 若<span class="symbol">$</span><span class="keyword">file</span>没设定，则将my.<span class="keyword">file</span>.txt输出至STDERR。（空值及非空值时不作处理）</span><br><span class="line"><span class="symbol">$</span>&#123;<span class="keyword">file</span>:?my.<span class="keyword">file</span>.txt&#125;   # 若<span class="symbol">$</span><span class="keyword">file</span>没设定或为空值，则将my.<span class="keyword">file</span>.txt输出至STDERR。（非空值时不作处理）</span><br></pre></td></tr></table></figure>
<p>Tips:</p>
<blockquote>
<p>以上的理解在于，你一定要分清楚unset与null及non-null这三种赋值状态。一般而言，<code>:</code> 与null有关，若不带 <code>:</code> 的话，null不受影响，若带 <code>:</code> 则连null也受影响。</p>
</blockquote>
<p>还有哦，${<code>#</code>var} 可计算出变量值的长度：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#<span class="keyword">file</span>&#125; # 可得到<span class="number">27</span>，因为<span class="regexp">/dir1/</span>dir2<span class="regexp">/dir3/my</span>.<span class="keyword">file</span>.txt刚好是<span class="number">27</span>个字节…</span><br></pre></td></tr></table></figure>
<p>接下来，再为大家介稍一下bash的数组（array）处理方法。</p>
<p>一般而言，<code>A=&quot;a b c def&quot;</code>这样的变量只是将$A替换为一个单一的字串，但是改为<code>A=(a b c def)</code>，则是将$A定义为数组…bash的数组替换方法可参考如下方法:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;A[@]&#125;</span>或<span class="variable">$&#123;A[*]&#125;</span> <span class="comment"># 可得到a b c def（全部组数）</span></span><br><span class="line"><span class="variable">$&#123;A[0]&#125;</span> <span class="comment"># 可得到a（第一个组数），$&#123;A[1]&#125;则为第二个组数…</span></span><br><span class="line"><span class="variable">$&#123;#A[@]&#125;</span>或<span class="variable">$&#123;#A[*]&#125;</span> <span class="comment">#可得到4（全部组数数量）</span></span><br><span class="line"><span class="variable">$&#123;#A[0]&#125;</span> <span class="comment">#可得到1（即第一个组数（a）的长度），$&#123;#A[3]&#125;可得到3（第四个组数（def）的长度）</span></span><br><span class="line">A[<span class="number">3</span>]=xyz <span class="comment"># 则是将第四个组数重新定义为xyz…</span></span><br></pre></td></tr></table></figure>
<p>能够善用bash的<code>$()</code>与<code>$&#123;&#125;</code>可大大提高及简化shell在变量上的处理能力哦</p>
<p>好了，最后为大家介绍<code>$(())</code>的用途吧：它是用来作整数运算的。在bash中，<code>$(())</code>的整数运算符号大致有这些：+ - * /：分别为“加、减、乘、除”。%：余数运算。&amp; | ^！：分别为“AND、OR、XOR、NOT”运算。</p>
<p>例：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ a=<span class="number">5</span>;b=<span class="number">7</span>;c=<span class="number">2</span></span><br><span class="line">$ echo <span class="constructor">$((<span class="params">a</span>+<span class="params">b</span><span class="operator">*</span><span class="params">c</span>)</span>)</span><br><span class="line"><span class="number">19</span></span><br><span class="line">$ echo <span class="constructor">$(((<span class="params">a</span>+<span class="params">b</span>)</span>/c))</span><br><span class="line"><span class="number">6</span></span><br><span class="line">$ echo <span class="constructor">$(((<span class="params">a</span><span class="operator">*</span><span class="params">b</span>)</span>%c))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在<code>$(())</code>中的变量名称，可于其前面加$符号来替换，也可以不用，如：<br><code>$(($a + $b * $c))</code>也可得到19的结果</p>
<p>此外，<code>$(())</code>还可作不同进位（如二进位、八进位、十六进位）作运算呢，只是，输出结果皆为十进制而已：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> $((<span class="number">16</span>#<span class="number">2</span>a)) # 结果为<span class="number">42</span>（<span class="number">16</span>进位转十进制）</span><br></pre></td></tr></table></figure>
<p>以一个实用的例子来看看吧：假如当前的umask是022，那么新建文件的权限即为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">umask</span> 022</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;obase=8;echo&quot;</span>obase=8;((8<span class="comment">#666 &amp; (8#777 ^ 8#$(umask))))&quot; | bc</span></span><br><span class="line">644</span><br></pre></td></tr></table></figure>
<p>事实上，单纯用<code>(())</code>也可重定义变量值，或作testing：</p>
<p>a=5；((a++)) #可将$a重定义为6<br>a=5；((a–)) 则为a=4<br>a=5；b=7；((a &lt; b)) 会得到0（true）的返回值。</p>
<p>常见的用于(())的测试符号有如下这些：<br>&lt;：小于<br>&gt;：大于<br>&lt;=：小于或等于<br>&gt;=：大于或等于<br>==：等于<br>!=：不等于</p>
<p>不过，使用<code>(())</code>作整数测试时，请不要跟<code>[ ]</code>的整数测试搞混乱了。（更多的测试我将于第十章为大家介绍）怎样？好玩吧.. okay，这次暂时说这么多…</p>
<p>上面的介绍，并没有详列每一种可用的状态，更多的，就请读者参考手册文件啰…</p>
<h2 id="第9问：-与-与-差在哪？"><a href="#第9问：-与-与-差在哪？" class="headerlink" title="第9问：@ 与@与* 差在哪？"></a>第9问：@ 与@与* 差在哪？</h2><p>要说<code>$@</code>与<code>$*</code>之前，需得先从shell script的<code>positional parameter</code>谈起…</p>
<p>我们都已经知道变量（variable）是如何定义及替换的，这个不用再多讲了。但是，我们还需要知道有些变量是shell内定的，且其名称是我们不能随意修改的，其中就有positional parameter在内。在shell script中，我们可用0，0，1，2，2，3…这样的变量分别提取命令行中的如下部份：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">script_name</span> parameter<span class="number">1</span> parameter<span class="number">2</span> parameter<span class="number">3</span>…</span><br></pre></td></tr></table></figure>
<p>我们很容易就能猜出<code>$0</code>就是代表shell script名称（路径）本身，而<code>$1</code>就是其后的第一个参数，如此类推… 须得留意的是<code>IFS</code>的作用，也就是，若<code>IFS</code>被quoting处理后，那么positional parameter也会改变。如下例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">my</span>.sh p<span class="number">1</span> <span class="string">&quot;p2 p3&quot;</span> p<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>由于在p2与p3之间的空白键被soft quote所关闭了，因此my.sh中的<code>$2</code>是”p2 p3”而<code>$3</code>则是p4…</p>
<p>还记得前两章我们提到<code>function</code>时，我不是说过它是script中的script吗？ 是的，function一样可以读取自己的（有别于script的）postitional parameter，惟一例外的是$0而已。举例而言：假设my.sh里有一个fucntion叫<code>my_fun</code>，若在script中跑<code>my_fun fp1 fp2 fp3</code>，那么，function内的<code>$0</code>是my.sh，而$1则是fp1而非p1了…不如写个简单的my.sh script看看吧：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">my_fun</span></span>() &#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$0 inside function is &#x27;</span><span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$1 inside function is &#x27;</span><span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$2 inside function is &#x27;</span><span class="variable">$2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$0 outside function is &#x27;</span><span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$1 outside function is &#x27;</span><span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$2 outside function is &#x27;</span><span class="variable">$2</span></span><br><span class="line">my_fun fp1 <span class="string">&quot;fp2 fp3&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后在command line中跑一下script就知道了：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chmod +x my.sh</span><br><span class="line">./my.sh p1 &quot;p2 p3&quot;</span><br><span class="line"><span class="meta">$0</span> outside <span class="keyword">function</span> <span class="keyword">is</span> ./my.sh</span><br><span class="line"><span class="meta">$1</span> outside <span class="keyword">function</span> <span class="keyword">is</span> p1</span><br><span class="line"><span class="meta">$2</span> outside <span class="keyword">function</span> <span class="keyword">is</span> p2 p3</span><br><span class="line"><span class="meta">$0</span> inside <span class="keyword">function</span> <span class="keyword">is</span> ./my.sh</span><br><span class="line"><span class="meta">$1</span> inside <span class="keyword">function</span> <span class="keyword">is</span> fp1</span><br><span class="line"><span class="meta">$2</span> inside <span class="keyword">function</span> <span class="keyword">is</span> fp2 fp3</span><br></pre></td></tr></table></figure>
<p>然而，在使用positional parameter的时候，我们要注意一些陷井哦：</p>
<blockquote>
<p>10不是替换第10个参数，而是替换第一个参数（10不是替换第10个参数，而是替换第一个参数（1）然后再补一个0于其后!</p>
</blockquote>
<p>也就是，<code>my.sh one two three four five six seven eigth nine ten</code>这样的command line，my.sh里的<code>$10</code>不是ten而是one0哦…小心小心!要抓到ten的话，有两种方法：</p>
<p>方法一是使用我们上一章介绍的<code>$&#123; &#125;</code>，也就是用<code>$&#123;10&#125;</code>即可。</p>
<p>方法二，就是shift了。用通俗的说法来说，所谓的shift就是取消positional parameter中最左边的参数（$0不受影响）。其预设值为1，也就是<code>shift</code>或<code>shift 1</code>都是取消<code>$1</code>，而原本的<code>$2</code>则变成<code>$1</code>、<code>$3</code>变成<code>$2</code>…若<code>shift 3</code>则是取消前面三个参数，也就是原本的<code>$4</code>将变成<code>$1</code>…</p>
<p>那，亲爱的读者，你说要<code>shift</code>掉多少个参数，才可用1取得1取得{10}呢？</p>
<p>okay，当我们对positional parameter有了基本概念之后，那再让我们看看其他相关变量吧。</p>
<p>首先是<code>$#</code>：它可抓出positional parameter的数量。以前面的<code>my.sh p1 &quot;p2 p3&quot;</code>为例：由于p2与p3之间的IFS是在soft quote中，因此<code>$#</code>可得到2的值。但如果p2与p3没有置于quoting中话，那<code>$#</code>就可得到3的值了。同样的道理在function中也是一样的…</p>
<p>因此，我们常在shell script里用如下方法测试script是否有读进参数：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ $# = <span class="number">0</span> ]</span><br></pre></td></tr></table></figure>
<p>假如为0，那就表示script没有参数，否则就是有带参数…</p>
<p>接下来就是<code>$@</code>与<code>$*</code>：精确来讲，两者只有在soft quote中才有差异，否则，都表示“全部参数”（$0除外）。举例来说好了：若在command line上跑<code>my.sh p1 &quot;p2 p3&quot; p4</code>的话，不管是<code>$@</code>还是<code>$*</code>，都可得到p1 p2 p3 p4就是了。但是，如果置于soft quote中的话：</p>
<ul>
<li><code>&quot;$@&quot;</code> 则可得到”p1” “p2 p3” “p4”这三个不同的词段（word）</li>
<li><code>&quot;$*&quot;</code> 则可得到”p1 p2 p3 p4”这一整串单一的词段。</li>
</ul>
<p>我们可修改一下前面的my.sh，使之内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">my_fun</span></span>() &#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$#</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;the number of parameter in &quot;$@&quot; is &#x27;</span>$(my_fun <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;the number of parameter in &quot;$*&quot; is &#x27;</span>$(my_fun <span class="string">&quot;$*&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后再执行./my.sh p1 “p2 p3” p4就知道@与@与*差在哪了…</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> parameter <span class="keyword">in</span> <span class="string">&quot;$@&quot;</span> <span class="keyword">is</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> parameter <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span> <span class="keyword">is</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="第10问：-amp-amp-与-差在哪？"><a href="#第10问：-amp-amp-与-差在哪？" class="headerlink" title="第10问：&amp;&amp; 与 || 差在哪？"></a>第10问：&amp;&amp; 与 || 差在哪？</h2><p>好不容易，进入两位数的章节了…一路走来，很辛苦吧？也很快乐吧？ 在解答本章题目之前，先让我们了解一个概念：<code>return value</code>!</p>
<p>我们在shell下跑的每一个command或function，在结束的时候都会传回父行程一个值，称为return value。在shell command line中可用<code>$?</code>这个变量得到最<code>&quot;新&quot;</code>的一个return value，也就是刚结束的那个行程传回的值。Return Value（RV）的取值为0-255之间，由程序（或script）的作者自行定议：</p>
<ul>
<li>若在<code>script</code>里，用<code>exit RV</code>来指定其值，若没指定，在结束时以最后一道命令之RV为值。</li>
<li>若在<code>function</code>里，则用<code>return RV</code>来代替<code>exit RV</code>即可。</li>
</ul>
<p>Return Value的作用，是用来判断行程的退出状态（exit status），只有两种：</p>
<ul>
<li>0的话为“真”（true）</li>
<li>非0的话为“假”（false）</li>
</ul>
<p>举个例子来说明好了：假设当前目录内有一份my.file的文件，而no.file是不存在的：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> touch my.<span class="keyword">file</span></span><br><span class="line"><span class="symbol">$</span> ls my.<span class="keyword">file</span></span><br><span class="line"><span class="symbol">$</span> echo <span class="symbol">$</span>? # first echo</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="symbol">$</span> ls <span class="keyword">no</span>.<span class="keyword">file</span></span><br><span class="line">ls: <span class="keyword">no</span>.<span class="keyword">file</span>: <span class="keyword">No</span> such <span class="keyword">file</span> <span class="keyword">or</span> directory</span><br><span class="line"><span class="symbol">$</span> echo <span class="symbol">$</span>? # second echo</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="symbol">$</span> echo <span class="symbol">$</span>? # third echo</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>上例的第一个echo是关于<code>ls my.file</code>的RV，可得到0的值，因此为true;第二个echo是关于<code>ls no.file</code>的RV，则得到非0的值，因此为false;第三个echo是关于第二个<code>echo $?</code>的RV，为0的值，因此也为true。</p>
<p>请记住：每一个command在结束时都会送回return value的! 不管你跑甚么样的命令…然而，有一个命令却是”专门”用来测试某一条件而送出return value以供true或false的判断，它就是<code>test</code>命令了!</p>
<p>若你用的是bash，请在command line下打<code>man test</code>或<code>man bash</code>来了解这个<code>test</code>的用法。这是你可用作参考的最精确的文件了，要是听别人说的，仅作参考就好…下面我只简单作一些辅助说明，其余的一律以man为准：</p>
<p>首先，test的表示式我们称为<code>expression</code>，其命令格式有两种：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>expression </span><br><span class="line">or:</span><br><span class="line">[ expression ]</span><br></pre></td></tr></table></figure>
<p>（请务必注意[ ]之间的空白键﹗）</p>
<p>用哪一种格式没所谓，都是一样的效果。（我个人比较喜欢后者…）其次，bash的test目前支持的测试对像只有三种：</p>
<ul>
<li>string：字串，也就是纯文字。</li>
<li>integer：整数（0或正整数，不含负数或小数点）。</li>
<li>file：文件。</li>
</ul>
<p>请初学者一定要搞清楚这三者的差异，因为test所用的expression是不一样的。</p>
<p>以A=123这个变量为例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="subst">$A</span>&quot;</span> = <span class="number">123</span> ]  <span class="comment"># 是字串的测试，以测试$A是否为1、2、3这三个连续的“文字”。</span></span><br><span class="line">[ <span class="string">&quot;A&quot;</span> -eq <span class="number">123</span> ] <span class="comment"># 是整数的测试，以测试$A是否等于“一百二十三”。</span></span><br><span class="line">[ -e <span class="string">&quot;<span class="subst">$A</span>&quot;</span> ]     <span class="comment"># 是关于文件的测试，以测试123这份“文件”是否存在。</span></span><br></pre></td></tr></table></figure>
<p>第三，当expression测试为“真”时，test就送回<code>0（true）</code>的return value，否则送出非<code>0（false）</code>。若在expression之前加上一个<code>!</code>（感叹号），则是当expression为“假时”才送出0，否则送出非0。</p>
<p>同时，test也允许多重的复合测试：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">expression1</span> -a expression<span class="number">2</span> # 当两个exrepssion都为true，才送出<span class="number">0</span>，否则送出非<span class="number">0</span>。</span><br><span class="line"><span class="attribute">expression1</span> -o expression<span class="number">2</span> # 只需其中一个exrepssion为true，就送出<span class="number">0</span>，只有两者都为false才送出非<span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -d <span class="string">&quot;<span class="variable">$file</span>&quot;</span> -a -x <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ]</span><br></pre></td></tr></table></figure>
<p>是表示当$file是一个目录、且同时具有x权限时，test才会为true。</p>
<p>第四，在command line中使用test时，请别忘记命令行的“重组”特性，也就是在碰到meta时会先处理meta再重新组建命令行。（这个特性我在第二及第四章都曾反复强调过）比方说，若test碰到变量或命令替换时，若不能满足expression格式时，将会得到语法错误的结果。举例来说好了：关于<code>[ string1 = string2 ]</code>这个test格式，在=号两边必须要有字串，其中包括空（null）字串（可用soft quote或hard quote取得）。</p>
<p>假如$A目前没有定义，或被定议为空字串的话，那如下的写法将会失败：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ <span class="variable">$A</span> = abc ]</span></span><br><span class="line">[：=：unary operator expected</span><br></pre></td></tr></table></figure>
<p>这是因为命令行碰到这个meta时，会替换这个<em>meta</em>时，会替换A的值，然后再重组命令行，那就变成了：<code>[ = abc ]</code></p>
<p>如此一来=号左边就没有字串存在了，因此造成test的语法错误﹗但是，下面这个写法则是成立的：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> [ <span class="string">&quot;<span class="variable">$A</span>&quot;</span> = <span class="type">abc</span> ]</span><br><span class="line"><span class="variable">$</span> <span class="built_in">echo</span> <span class="variable">$</span>?</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这是因为在命令行重组后的结果为：<code>[ &quot;&quot; = abc ]</code>。由于=左边我们用soft quote得到一个空字串，而让test语法得以通过…读者诸君请务必留意这些细节哦，因为稍一不慎，将会导至test的结果变了个样!</p>
<p>若您对test还不是很有经验的话，那在使用test时不妨先采用如下这一个”法则”：</p>
<blockquote>
<p>假如在test中碰到变量替换，用soft quote是最保险的﹗若你对quoting不熟的话，请重新温习第四章的内容吧…</p>
</blockquote>
<p>okay，关于更多的test用法，老话一句：请看man page吧！ 虽然洋洋洒洒讲了一大堆，或许你还在嘀咕….那…那个return value有啥用啊？！问得好﹗</p>
<p>告诉你：return value的作用可大了﹗若你想让你的shell变“聪明”的话，就全靠它了：</p>
<blockquote>
<p>有了return value，我们可以让shell跟据不同的状态做不同的时情…</p>
</blockquote>
<p>这时候，才让我来揭晓本章的答案吧 &amp;&amp; 与 || 都是用来“组建”多个command line用的：</p>
<ul>
<li>command1 &amp;&amp; command2：其意思是command2只有在RV为0（true）的条件下执行。</li>
<li>command1 || command2：其意思是command2只有在RV为非0（false）的条件下执行。</li>
</ul>
<p>来，以例子来说好了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">&quot;<span class="variable">$A</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes!it&#x27;s ture.&quot;</span></span></span><br><span class="line">yes!it&#x27;s ture.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">&quot;<span class="variable">$A</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes!it&#x27;s ture.&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">&quot;<span class="variable">$A</span>&quot;</span> ] || <span class="built_in">echo</span> <span class="string">&quot;no,it&#x27;s NOT ture.&quot;</span></span></span><br><span class="line">no,it&#x27;s NOT ture.</span><br></pre></td></tr></table></figure>
<p>（注：<code>[ -n string ]</code>是测试string长度大于0则为true。）</p>
<p>上例的第一个<code>&amp;&amp;</code>命令行之所以会执行其右边的echo命令，是因为上一个test送回了0的RV值﹔但第二次就不会执行，因为test送回非0的结果…同理，||右边的echo会被执行，却正是因为左边的test送回非0所引起的。</p>
<p>事实上，我们在同一命令行中，可用多个&amp;&amp;或||来组建呢：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">&quot;<span class="variable">$A</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes！it&#x27;s ture.&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no，it&#x27;s NOT ture.&quot;</span></span></span><br><span class="line">yes!it&#x27;s ture.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">&quot;<span class="variable">$A</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes!it&#x27;s ture.&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no,it&#x27;s NOT ture.&quot;</span></span></span><br><span class="line">no,it&#x27;s NOT ture.</span><br></pre></td></tr></table></figure>
<p>怎样，从这一刻开始，你是否觉得我们的shell是“很聪明”的呢？ 好了，最后，布置一道习题给大家做做看…</p>
<p>下面的判断是：当<code>$A</code>被赋与值时，再看是否小于100，否则送出too big!：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">&quot;<span class="variable">$A</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$A</span>&quot;</span> -lt 100 ] || <span class="built_in">echo</span> <span class="string">&#x27;too big!&#x27;</span></span></span><br><span class="line">too big!</span><br></pre></td></tr></table></figure>
<p>若我将A取消，照理说，应该不会送文字才对啊（因为第一个条件就不成立了）…</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">&quot;<span class="variable">$A</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$A</span>&quot;</span> -lt 100 ] || <span class="built_in">echo</span> <span class="string">&#x27;too big!&#x27;</span></span></span><br><span class="line">too big!</span><br></pre></td></tr></table></figure>
<p>为何上面的结果也可得到呢？又，如何解决之呢？（提示：修改方法很多，其中一种方法可利用第七章介绍过的command group…）快﹗告我我答案﹗其余免谈…</p>
<h2 id="第11问：-gt-与-lt-差在哪？"><a href="#第11问：-gt-与-lt-差在哪？" class="headerlink" title="第11问：&gt; 与 &lt; 差在哪？"></a>第11问：&gt; 与 &lt; 差在哪？</h2><h3 id="11-1"><a href="#11-1" class="headerlink" title="11.1"></a>11.1</h3><p>谈到<code>I/O redirection</code>，不妨先让我们认识一下<code>File Descriptor</code>（FD）。程序的运算，在大部份情况下都是进行数据（data）的处理，这些数据从哪读进？又，送出到哪里呢？这就是File descriptor（FD）的功用了。</p>
<p>在shell程序中，最常使用的FD大概有三个，分别为：</p>
<ul>
<li>0: Standard Input（STDIN）</li>
<li>1: Standard Output（STDOUT）</li>
<li>2: Standard Error Output（STDERR）</li>
</ul>
<p>在标准情况下，这些FD分别跟如下设备（device）关联：</p>
<ul>
<li>stdin（0）：keyboard</li>
<li>stdout（1）：monitor</li>
<li>stderr（2）：monitor</li>
</ul>
<p>我们可以用如下下命令测试一下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mail -s test root</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> a test mail.</span><br><span class="line">please skip.</span><br><span class="line">^d（同时按crtl跟d键）</span><br></pre></td></tr></table></figure>
<p>很明显，mail程序所读进的数据，就是从<code>stdin</code>也就是keyboard读进的。不过，不见得每个程序的stdin都跟mail一样从keyboard读进，因为程序作者可以从档案参数读进stdin，如：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure>
<p>但，要是cat之后没有档案参数则又如何呢？哦，请您自己玩玩看啰….</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cat</span></span><br></pre></td></tr></table></figure>
<p>（请留意数据输出到哪里去了，最后别忘了按^d离开…）至于stdout与stderr，嗯…等我有空再续吧… 还是，有哪位前辈要来玩接龙呢？</p>
<h3 id="11-2"><a href="#11-2" class="headerlink" title="11.2"></a>11.2</h3><p>沿文再续，书接上一回… 相信，经过上一个练习后，你对<code>stdin</code>与<code>stdout</code>应该不难理解吧？然后，让我们继续看<code>stderr</code>好了。</p>
<p>事实上，stderr没甚么难理解的：说穿了就是“错误信息”要往哪边送而已…比方说，若读进的档案参数是不存在的，那我们在monitor上就看到了：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> <span class="keyword">no</span>.such.<span class="keyword">file</span></span><br><span class="line"><span class="keyword">ls</span>: <span class="keyword">no</span>.such.<span class="keyword">file</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure>
<p>若，一个命令同时产生stdout与stderr呢？那还不简单，都送到monitor来就好了：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> touch my.<span class="keyword">file</span></span><br><span class="line"><span class="symbol">$</span> ls my.<span class="keyword">file</span> <span class="keyword">no</span>.such.<span class="keyword">file</span></span><br><span class="line">ls: <span class="keyword">no</span>.such.<span class="keyword">file</span>: <span class="keyword">No</span> such <span class="keyword">file</span> <span class="keyword">or</span> directory</span><br><span class="line">my.<span class="keyword">file</span></span><br></pre></td></tr></table></figure>
<p>okay，至此，关于FD及其名称、还有相关联的设备，相信你已经没问题了吧？那好，接下来让我们看看如何改变这些FD的预设数据信道，我们可用<code>&lt;</code>来改变读进的数据信道（stdin），使之从指定的档案读进。我们可用<code>&gt;</code>来改变送出的数据信道（stdout，stderr），使之输出到指定的档案。比方说：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; <span class="keyword">my</span>.<span class="built_in">file</span></span><br></pre></td></tr></table></figure>
<p>就是从my.file读进数据</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mail -s test root &lt; <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure>
<p>则是从<code>/etc/passwd</code>读进…</p>
<p>这样一来，stdin将不再是从keyboard读进，而是从档案读进了…严格来说，<code>&lt;</code>符号之前需要指定一个FD的（之间不能有空白），但因为<code>0</code>是<code>&lt;</code>的预设值，因此<code>&lt;</code>与<code>0&lt;</code>是一样的!okay，这个好理解吧？</p>
<p>那，要是用两个<code>&lt;&lt;</code>又是啥呢？这是所谓的<code>HERE Document</code>，它可以让我们输入一段文本，直到读到<code>&lt;&lt;</code>后指定的字串。比方说：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;FINISH</span><br><span class="line"><span class="keyword">first</span> <span class="built_in">line</span> here</span><br><span class="line"><span class="keyword">second</span> <span class="built_in">line</span> there</span><br><span class="line"><span class="keyword">third</span> <span class="built_in">line</span> nowhere</span><br><span class="line">FINISH</span><br></pre></td></tr></table></figure>
<p>这样的话，cat会读进3行句子，而无需从keyboard读进数据且要等^d结束输入。至于<code>&gt;</code>又如何呢？且听下回分解…</p>
<h3 id="11-3"><a href="#11-3" class="headerlink" title="11.3"></a>11.3</h3><p>okay，又到讲古时间~当你搞懂了<code>0&lt;</code>原来就是改变<code>stdin</code>的数据输入信道之后，相信要理解如下两个redirection就不难了：<code>1&gt;</code> <code>2&gt;</code> 。前者是改变<code>stdout</code>的数据输出信道，后者是改变<code>stderr</code>的数据输出信道。两者都是将原本要送出到monitor的数据转向输出到指定档案去。</p>
<p>由于<code>1</code>是<code>&gt;</code>的预设值，因此，<code>1&gt;</code>与<code>&gt;</code>是相同的，都是改变<code>stdout</code>。用上次的ls例子来说明一下好了：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> my.<span class="keyword">file</span> <span class="keyword">no</span>.such.<span class="keyword">file</span> 1&gt;<span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line"><span class="keyword">ls</span>: <span class="keyword">no</span>.such.<span class="keyword">file</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure>
<p>这样monitor就只剩下stderr而已。因为stdout给写进<code>file.out</code>去了。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> my.<span class="keyword">file</span> <span class="keyword">no</span>.such.<span class="keyword">file</span> 2&gt;<span class="keyword">file</span>.<span class="keyword">err</span></span><br><span class="line">my.<span class="keyword">file</span></span><br></pre></td></tr></table></figure>
<p>这样monitor就只剩下stdout，因为stderr写进了<code>file.err</code>。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> my.<span class="keyword">file</span> <span class="keyword">no</span>.such.<span class="keyword">file</span> 1&gt;<span class="keyword">file</span>.<span class="keyword">out</span> 2&gt;<span class="keyword">file</span>.<span class="keyword">err</span></span><br></pre></td></tr></table></figure>
<p>这样monitor就啥也没有，因为stdout与stderr都给转到档案去了…</p>
<p>呵~看来要理解<code>&gt;</code>一点也不难啦﹗是不？没骗你吧？ 不过，有些地方还是要注意一下的。<br>首先，是同时写入的问题。比方如下这个例子：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> ls my.<span class="keyword">file</span> <span class="keyword">no</span>.such.<span class="keyword">file</span> <span class="number">1</span>&gt;<span class="keyword">file</span>.both <span class="number">2</span>&gt;<span class="keyword">file</span>.both</span><br></pre></td></tr></table></figure>
<p>假如stdout（1）与stderr（2）都同时在写入file.both的话，则是采取“覆盖”方式：后来写入的<code>覆盖</code>前面的。让我们假设一个stdout与stderr同时写入file.out的情形好了：</p>
<ul>
<li>首先stdout写入10个字元</li>
<li>然后stderr写入6个字元</li>
</ul>
<p>那么，这时候原本stdout输出的10个字元就被stderr覆盖掉了。那，如何解决呢？所谓山不转路转、路不转人转嘛，我们可以换一个思维：将stderr导进stdout或将stdout导进sterr，而不是大家在抢同一份档案，不就行了﹗bingo﹗就是这样啦：</p>
<ul>
<li><code>2&gt;&amp;1</code>就是将<code>stderr</code>并进<code>stdout</code>作输出</li>
<li><code>1&gt;&amp;2</code>或<code>&gt;&amp;2</code>就是将<code>stdout</code>并进<code>stderr</code>作输出</li>
</ul>
<p>于是，前面的错误操作可以改为：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> ls my.<span class="keyword">file</span> <span class="keyword">no</span>.such.<span class="keyword">file</span> <span class="number">1</span>&gt;<span class="keyword">file</span>.both <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">或</span><br><span class="line"><span class="symbol">$</span> ls my.<span class="keyword">file</span> <span class="keyword">no</span>.such.<span class="keyword">file</span> <span class="number">2</span>&gt;<span class="keyword">file</span>.both &gt;&amp;<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这样，不就皆大欢喜了吗？呵 不过，光解决了同时写入的问题还不够，我们还有其他技巧需要了解的。故事还没结束，别走开﹗广告后，我们再回来…﹗</p>
<h3 id="11-4"><a href="#11-4" class="headerlink" title="11.4"></a>11.4</h3><p>okay，这次不讲I/O Redirction，讲佛吧…（有没搞错？﹗网中人是否头壳烧坏了？…）嘻</p>
<p>学佛的最高境界，就是“四大皆空”。至于是空哪四大块？我也不知，因为我还没到那境界…但这个“空”字，却非常值得我们返复把玩的：—色即是空、空即是色﹗好了，施主要是能够领会“空”的禅意，那离修成正果不远矣~</p>
<p>在Linux档案系统里，有个设备档位于<code>/dev/null</code>。许多人都问过我那是甚么玩意儿？我跟你说好了：那就是“空”啦﹗没错﹗空空如也的空就是null了….请问施主是否忽然有所顿误了呢？然则恭喜了 这个null在I/O Redirection中可有用得很呢：</p>
<ul>
<li>若将<code>FD1</code>跟<code>FD2</code>转到<code>/dev/null</code>去，就可将stdout与stderr弄不见掉。</li>
<li>若将<code>FD0</code>接到<code>/dev/null</code>来，那就是读进nothing。</li>
</ul>
<p>比方说，当我们在执行一个程序时，画面会同时送出stdout跟stderr，<br>假如你不想看到stderr（也不想存到档案去），那可以：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls my.<span class="keyword">file</span> no.such.<span class="keyword">file</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="keyword">null</span></span><br><span class="line">my.<span class="keyword">file</span></span><br></pre></td></tr></table></figure>
<p>若要相反：只想看到stderr呢？还不简单﹗将stdout弄到null就行：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> my.<span class="keyword">file</span> <span class="keyword">no</span>.such.<span class="keyword">file</span> &gt;/dev/null</span><br><span class="line"><span class="keyword">ls</span>: <span class="keyword">no</span>.such.<span class="keyword">file</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure>
<p>那接下来，假如单纯只跑程序，不想看到任何输出结果呢？哦，这里留了一手上次节目没讲的法子，专门赠予有缘人﹗… 除了用<code>&gt;/dev/null 2&gt;&amp;1</code>之外，你还可以如此：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls my.<span class="keyword">file</span> no.such.<span class="keyword">file</span> &amp;&gt;<span class="regexp">/dev/</span><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>（提示：将<code>&amp;&gt;</code>换成<code>&gt;&amp;</code>也行啦~！）</p>
<p>okay？讲完佛，接下来，再让我们看看如下情况：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">&quot;1&quot;</span> &gt; <span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line">$ <span class="keyword">cat</span> <span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line">1</span><br><span class="line">$ echo <span class="string">&quot;2&quot;</span> &gt; <span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line">$ <span class="keyword">cat</span> <span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>看来，我们在重导stdout或stderr进一份档案时，似乎永远只获得最后一次导入的结果。那，之前的内容呢？呵<br>要解决这个问提很简单啦，将<code>&gt;</code>换成<code>&gt;&gt;</code>就好：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">&quot;3&quot;</span> &gt;&gt; <span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line">$ <span class="keyword">cat</span> <span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>如此一来，被重导的目标档案之内容并不会失去，而新的内容则一直增加在最后面去。easy？呵…</p>
<p>但，只要你再一次用回单一的<code>&gt;</code>来重导的话，那么，旧的内容还是会被“洗”掉的﹗这时，你要如何避免呢？—-备份﹗yes，我听到了﹗不过….还有更好的吗？既然与施主这么有缘份，老纳就送你一个锦囊妙法吧：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> <span class="keyword">set</span> -o <span class="comment">noclobber</span></span><br><span class="line">$ echo <span class="comment">&quot;4&quot;</span> <span class="comment">&gt; file.out</span></span><br><span class="line">-bash: file: cannot <span class="comment">overwrite existing file</span></span><br></pre></td></tr></table></figure>
<p>那，要如何取消这个“限制”呢？哦，将<code>set -o</code>换成<code>set +o</code>就行：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">set</span> +o noclobber</span><br><span class="line">$ echo <span class="string">&quot;5&quot;</span> &gt; <span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line">$ <span class="keyword">cat</span> <span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>再问：那…有办法不取消而又“临时”盖写目标档案吗？哦，佛曰：不可告也﹗啊开玩笑的、开玩笑的啦唉，早就料到人心是不足的了﹗</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">set</span> -o noclobber</span><br><span class="line">$ echo <span class="string">&quot;6&quot;</span> &gt;| <span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line">$ <span class="keyword">cat</span> <span class="keyword">file</span>.<span class="keyword">out</span></span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>留意到没有：在&gt;后面再加个“|”就好（注意：&gt;与|之间不能有空白哦）… 呼…（深呼吸吐纳一下吧）再来还有一个难题要你去参透的呢：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> echo <span class="string">&quot;some text here&quot;</span> &gt; <span class="keyword">file</span></span><br><span class="line"><span class="symbol">$</span> cat &lt; <span class="keyword">file</span></span><br><span class="line">some text here</span><br><span class="line"><span class="symbol">$</span> cat &lt; <span class="keyword">file</span> &gt; <span class="keyword">file</span>.bak</span><br><span class="line"><span class="symbol">$</span> cat &lt; <span class="keyword">file</span>.bak</span><br><span class="line">some text here</span><br><span class="line"><span class="symbol">$</span> cat &lt; <span class="keyword">file</span> &gt; <span class="keyword">file</span></span><br><span class="line"><span class="symbol">$</span> cat &lt; <span class="keyword">file</span></span><br></pre></td></tr></table></figure>
<p>嗯？！注意到没有？！！—-怎么最后那个cat命令看到的file竟是空的？﹗why？why？why？同学们：下节课不要迟到啰！</p>
<h3 id="11-5"><a href="#11-5" class="headerlink" title="11.5"></a>11.5</h3><p>当当当上课啰<br>前面提到：<code>$ cat &lt; file &gt; file</code> 之后原本有内容的档案结果却被洗掉了﹗要理解这一现像其实不难，这只是priority的问题而已：</p>
<p>在IO Redirection中，stdout与stderr的管道会先准备好，才会从stdin读进数据。也就是说，在上例中，<code>&gt; file</code>会先将file清空，然后才读进<code>&lt; file</code>，但这时候档案已经被清空了，因此就变成读不进任何数据了…哦原来如此~</p>
<p>那…如下两例又如何呢？</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> cat &lt;&gt; <span class="keyword">file</span></span><br><span class="line"><span class="symbol">$</span> cat &lt; <span class="keyword">file</span> &gt;&gt; <span class="keyword">file</span></span><br></pre></td></tr></table></figure>
<p>嗯…同学们，这两个答案就当练习题啰，下节课之前请交作业﹗好了，I/O Redirection也快讲完了，sorry，因为我也只知道这么多而已啦嘻~  不过，还有一样东东是一定要讲的，各位观众（请自行配乐~！#@！$%）：—-就是pipe line也！</p>
<p>谈到<code>pipe line</code>，我相信不少人都不会陌生：我们在很多command line上常看到的“|”符号就是pipe line了。不过，究竟pipe line是甚么东东呢？别急别急…先查一下英汉字典，看看pipe是甚么意思？没错﹗它就是“水管”的意思…那么，你能想像一下水管是怎么一根接着一根的吗？又，每根水管之间的input跟output又如何呢？嗯？？灵光一闪：原来pipe line的I/O跟水管的I/O是一模一样的：<code>上一个命令的stdout接到下一个命令的stdin去了!</code>的确如此…不管在command line上你使用了多少个pipe line，前后两个command的I/O都是彼此连接的﹗（恭喜：你终于开窍了﹗）</p>
<p>不过…然而…但是……stderr呢？好问题﹗不过也容易理解：若水管漏水怎么办？也就是说：在pipe line之间，前一个命令的stderr是不会接进下一命令的stdin的，其输出，若不用<code>2&gt;</code>导到file去的话，它还是送到摄像头上面来﹗这点请你在pipe line运用上务必要注意的。那，或许你又会问：有办法将stderr也喂进下一个命令的stdin去吗？（贪得无厌的家伙﹗）方法当然是有，而且你早已学过了﹗ 我提示一下就好：请问你如何将stderr合并进stdout一同输出呢？若你答不出来，下课之后再来问我吧…（如果你脸皮真够厚的话…）</p>
<p>或许，你仍意尤未尽﹗或许，你曾经碰到过下面的问题：</p>
<p>在<code>cm1 | cm2 | cm3…</code>这段pipe line中，若要将<code>cm2</code>的结果存到某一档案呢？</p>
<p>若你写成<code>cm1 | cm2 &gt; file | cm3</code>的话，那你肯定会发现cm3的stdin是空的﹗（当然啦，你都将水管接到别的水池了﹗）聪明的你或许会如此解决：<code>cm1 | cm2 &gt; file; cm3 &lt; file</code> 是的，你的确可以这样做，但最大的坏处是：这样一来，file I/O会变双倍﹗在command执行的整个过程中，file I/O是最常见的最大性能杀手。凡是有经验的shell操作者，都会尽量避免或降低file I/O的频率。那，上面问题还有更好方法吗？有的，那就是<code>tee</code>命令了。</p>
<p>所谓<code>tee</code>命令是在不影响原本I/O的情况下，将stdout复制一份到档案去。因此，上面的命令行可以如此打：</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cm1 | cm2 | tee file | cm3</span><br></pre></td></tr></table></figure>
<p>在预设上，tee会改写目标档案，若你要改为增加内容的话，那可用<code>-a</code>参数达成。<br>基本上，pipe line的应用在shell操作上是非常广泛的，尤其是在text filtering方面，<br>凡举<code>cat</code>，<code>more</code>，<code>head</code>，<code>tail</code>，<code>wc</code>，<code>expand</code>，<code>tr</code>，<code>grep</code>，<code>sed</code>，<code>awk</code>，…等等文字处理工具，搭配起pipe line来使用，你会惊觉command line原来是活得如此精彩的﹗常让人有“众里寻他千百度，蓦然回首，那人却在灯火阑珊处﹗”之感…</p>
<p>好了，关于I/O Redirection的介绍就到此告一段落。若日后有空的话，再为大家介绍其它在shell上好玩的东西﹗bye…</p>
<h2 id="第12问：你要-if-还是-case-呢？"><a href="#第12问：你要-if-还是-case-呢？" class="headerlink" title="第12问：你要 if 还是 case 呢？"></a>第12问：你要 if 还是 case 呢？</h2><p>放了一个愉快的春节假期，人也变得懒懒散散的…只是，答应了大家的作业，还是要坚持完成就是了~</p>
<p>还记得我们在第10章所介绍的return value吗？是的，接下来介绍的内容与之有关，若你的记忆也被假期的欢乐时光所抵消掉的话，那，建议您还是先回去温习温习再回来…</p>
<p>若你记得return value，我想你也应该记得了<code>&amp;&amp;</code>与<code>||</code>是甚么意思吧？用这两个符号再配搭command group的话，我们可让shell script变得更加聪明哦。比方说：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">comd1</span> &amp;&amp; &#123;</span><br><span class="line">    comd2</span><br><span class="line">    comd3</span><br><span class="line">    :</span><br><span class="line">&#125; || &#123;</span><br><span class="line">    comd4</span><br><span class="line">    comd5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意思是说：假如comd1的return value为true的话，然则执行comd2与comd3，否则执行comd4与comd5。</p>
<p>事实上，我们在写shell script的时候，经常需要用到这样那样的条件以作出不同的处理动作。<br>用<code>&amp;&amp;</code>与<code>||</code>的确可以达成条件执行的效果，然而，从“人类语言”上来理解，却不是那么直观。<br>更多时候，我们还是喜欢用if….then…else…这样的keyword来表达条件执行。在bash shell中，我们可以如此修改上一段代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> comd1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    comd2</span><br><span class="line">    comd3</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    comd4</span><br><span class="line">    comd5</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>这也是我们在shell script中最常用到的<code>if</code>判断式：只要if后面的command line返回true的return value（我们最常用test命令来送出return value），然则就执行then后面的命令，否则执行else后的命令;fi则是用来结束判断式的keyword。</p>
<p>在if判断式中，else部份可以不用，但then是必需的。（若then后不想跑任何command，可用<code>:</code>这个null command代替）。当然，then或else后面，也可以再使用更进一层的条件判断式，这在shell script设计上很常见。</p>
<p>若有多项条件需要“依序”进行判断的话，那我们则可使用<code>elif</code>这样的keyword：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> comd1; <span class="keyword">then</span></span><br><span class="line">    comd2</span><br><span class="line"><span class="keyword">elif</span> comd3; <span class="keyword">then</span></span><br><span class="line">    comd4</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    comd5</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>意思是说：若comd1为true，然则执行comd2;否则再测试comd3，然则执行comd4;倘若comd1与comd3均不成立，那就执行comd5。</p>
<p>if判断式的例子很常见，你可从很多shell script中看得到，我这里就不再举例子了…接下来要为大家介绍的是case判断式。</p>
<p>虽然if判断式已可应付大部份的条件执行了，然而，在某些场合中，却不够灵活，尤其是在string式样的判断上，比方如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QQ() &#123;</span><br><span class="line">    echo -n <span class="string">&quot;Do you want to continue?(Yes/No):&quot;</span></span><br><span class="line">    read YN</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;$YN&quot;</span> = Y -o <span class="string">&quot;$YN&quot;</span> = y -o <span class="string">&quot;$YN&quot;</span> = <span class="string">&quot;Yes&quot;</span> -o <span class="string">&quot;$YN&quot;</span> = <span class="string">&quot;yes&quot;</span> -o <span class="string">&quot;$YN&quot;</span> = <span class="string">&quot;YES&quot;</span> ]</span><br><span class="line">    then</span><br><span class="line">        QQ</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">exit</span> <span class="number">0</span></span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">QQ</span><br></pre></td></tr></table></figure>
<p>从例中，我们看得出来，最麻烦的部份是在于判断YN的值可能有好几种式样。聪明的你或许会如此修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$YN</span>&quot;</span> | grep -q <span class="string">&#x27;^[Yy]\([Ee][Ss]\)*$&#x27;</span></span><br></pre></td></tr></table></figure>
<p>也就是用<code>Regular Expression</code>来简化代码。（我们有机会再来介绍RE）只是…是否有其它更方便的方法呢?有的，就是用case判断式即可：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QQ() &#123;</span><br><span class="line">    echo -n <span class="string">&quot;Do you want to continue?(Yes/No):&quot;</span></span><br><span class="line">    read YN</span><br><span class="line">    case <span class="string">&quot;$YN&quot;</span> <span class="keyword">in</span></span><br><span class="line">        [Yy]|[Yy][Ee][Ss])</span><br><span class="line">            QQ</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="keyword">exit</span> <span class="number">0</span></span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">&#125;</span><br><span class="line">QQ</span><br></pre></td></tr></table></figure>
<p>我们常用case的判断式来判断某一变量在不同的值（通常是string）时作出不同的处理，比方说，判断script参数以执行不同的命令。若你有兴趣、且用Linux系统的话，不妨挖一挖/etc/init.d/*里那堆script中的case用法。如下就是一例：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">case <span class="string">&quot;$1&quot;</span> <span class="keyword">in</span></span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        rhstatus</span><br><span class="line">        ;;</span><br><span class="line">    restart|reload)</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line">    condrestart)</span><br><span class="line">        [ -f <span class="regexp">/var/</span>lock<span class="regexp">/subsys/</span>syslog ] &amp;&amp; restart || :</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo $<span class="string">&quot;Usage: $0 &#123;start|stop|status|restart|condrestart&#125;&quot;</span></span><br><span class="line">        <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">    esac</span><br></pre></td></tr></table></figure>
<p>（若你对positional parameter的印像已经模糊了，请重看第9章吧。）okay，十三问还剩一问而已，过几天再来搞定之….</p>
<h2 id="第13问：for-what？while与until差在哪？"><a href="#第13问：for-what？while与until差在哪？" class="headerlink" title="第13问：for what？while与until差在哪？"></a>第13问：for what？while与until差在哪？</h2><p>终于，来到shell十三问的最后一问了…长长吐一口气~</p>
<p>最后要介绍的是shell script设计中常见的“循环”（loop）。所谓的loop就是script中的一段在一定条件下反复执行的代码。bash shell中常用的loop有如下三种：<code>for</code> <code>while</code> <code>until</code></p>
<p>for loop是从一个清单列表中读进变量值，并“依次”的循环执行do到done之间的命令行。例：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="literal">one</span> <span class="literal">two</span> <span class="literal">three</span> <span class="literal">four</span> <span class="literal">five</span></span><br><span class="line"><span class="built_in">do</span></span><br><span class="line">    echo <span class="comment">-----------</span></span><br><span class="line">    echo <span class="string">&#x27;$var is &#x27;</span>$var</span><br><span class="line">    echo</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>上例的执行结果将会是：</p>
<ol>
<li>for会定义一个叫var的变量，其值依次是one two three four five。</li>
<li>因为有5个变量值，因此do与done之间的命令行会被循环执行5次。</li>
<li>每次循环均用echo产生三行句子。而第二行中不在hard quote之内的<code>$var</code>会依次被替换为one two three four five。</li>
<li>当最后一个变量值处理完毕，循环结束。</li>
</ol>
<p>我们不难看出，在for loop中，变量值的多寡，决定循环的次数。然而，变量在循环中是否使用则不一定，得视设计需求而定。倘若for loop没有使用in这个keyword来指定变量值清单的话，其值将从<code>$@</code>（<code>或$*</code>）中继承：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">var</span>; <span class="keyword">do</span></span><br><span class="line">…</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>（若你忘记了positional parameter，请温习第9章…）</p>
<p>for loop用于处理“清单”（list）项目非常方便，其清单除了可明确指定或从positional parameter取得之外，也可从变量替换或命令替换取得…（再一次提醒：别忘了命令行的“重组”特性！）</p>
<p>然而，对于一些“累计变化”的项目（如整数加减），for亦能处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1;i&lt;=10;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;num is <span class="variable">$i</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>除了for loop，上面的例子我们也可改用while loop来做到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$num</span>&quot;</span> -le 10 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;num is <span class="variable">$num</span>&quot;</span></span><br><span class="line">    num=$((<span class="variable">$num</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>while loop的原理与for loop稍有不同：它不是逐次处理清单中的变量值，而是取决于while后面的命令行之return value：</p>
<ul>
<li>若为ture，则执行<code>do</code>与<code>done</code>之间的命令，然后重新判断<code>while</code>后的return value。</li>
<li>若为false，则不再执行do与done之间的命令而结束循环。</li>
</ul>
<p>分析上例：</p>
<ol>
<li>在while之前，定义变量num=1。</li>
<li>然后测试（test）$num是否小于或等于10。</li>
<li>结果为true，于是执行echo并将num的值加一。</li>
<li>再作第二轮测试，此时num的值为1+1=2，依然小于或等于10，因此为true，继续循环。</li>
<li>直到num为10+1=11时，测试才会失败…于是结束循环。</li>
</ol>
<p>我们不难发现：若while的测试结果永远为true的话，那循环将一直永久执行下去：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> : ;<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> looping…</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>上例的<code>:</code>是bash的null command，不做任何动作，除了送回true的return value。因此这个循环不会结束，称作死循环。死循环的产生有可能是故意设计的（如跑daemon），也可能是设计错误。若要结束死循环，可透过signal来终止（如按下ctrl-c）。（关于process与signal，等日后有机会再补充，十三问暂时略过。）</p>
<p>一旦你能够理解while loop的话，那，就能理解until loop：</p>
<blockquote>
<p>与while相反，until是在return value为false时进入循环，否则结束。</p>
</blockquote>
<p>因此，前面的例子我们也可以轻松的用until来写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line">until [ ! <span class="string">&quot;<span class="variable">$num</span>&quot;</span> -le 10 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;num is <span class="variable">$num</span>&quot;</span></span><br><span class="line">    num=$((<span class="variable">$num</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>或是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line">until [ <span class="string">&quot;<span class="variable">$num</span>&quot;</span> -gt 10 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;num is <span class="variable">$num</span>&quot;</span></span><br><span class="line">    num=$((<span class="variable">$num</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>okay，关于bash的三个常用的loop暂时介绍到这里。在结束本章之前，再跟大家补充两个与loop有关的命令：<code>break</code> <code>continue</code></p>
<p>这两个命令常用在复合式循环里，也就是在do…done之间又有更进一层的loop，当然，用在单一循环中也未尝不可啦…</p>
<p><code>break</code>是用来打断循环，也就是“强迫结束”循环。若break后面指定一个数值n的话，则“从里向外”打断第n个循环，预设值为<code>break 1</code>，也就是打断当前的循环。<br>在使用break时需要注意的是，它与return及exit是不同的：</p>
<ul>
<li>break是结束loop</li>
<li>return是结束function</li>
<li>exit是结束script/shell</li>
</ul>
<p>而<code>continue</code>则与<code>break</code>相反：强迫进入下一次循环动作。若你理解不来的话，那你可简单的看成：在<code>continue</code>到<code>done</code>之间的句子略过而返回循环顶端…与break相同的是：<code>continue</code>后面也可指定一个数值n，以决定继续哪一层（从里向外计算）的循环，预设值为<code>continue 1</code>，也就是继续当前的循环。<br>在shell script设计中，若能善用loop，将能大幅度提高script在复杂条件下的处理能力。请多加练习吧….</p>
<p>好了，该是到了结束的时候了。</p>
<p>婆婆妈妈的跟大家罗唆了一堆关于shell的基础概念，目的不是要告诉大家“答案”，而是要带给大家“启发”…在日后关于shell的讨论中，我或许会经常用“连接”方式指引回来十三问中的内容，以便我们在进行技术探讨时彼此能有一些讨论基础，而不至于各说各话、徒费时力。但，更希望十三问能带给你更多的思考与乐趣，至为重要的是透过实作来加深理解。</p>
<p>是的，我很重视“实作”与“独立思考”这两项学习要素，若你能够掌握其中真义，那请容我说声：<br>—恭喜﹗十三问你没白看了﹗</p>
<p>p.s.</p>
<p>至于补充问题部份，我暂时不写了。而是希望：</p>
<ol>
<li>大家扩充题目。</li>
<li>一起来写心得。</li>
</ol>
<p>Good luck and happy studying！</p>
<p>本文整理并转自CU上的帖子[<a target="_blank" rel="noopener" href="http://bbs.chinaunix.net/thread-218853-1-1.html">学习共享] shell 十三問?</a>，此贴是2003年发表的，但却是相当不错的linux基础知识汇集贴，原帖主使用的台湾风格，本文加以简体化和整理，转载自<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004324819">P_Chou水冗</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>shell十三问</p><p><a target="_blank" rel="noopener" href="http://bbs.chinaunix.net/thread-218853-1-1.html">http://bbs.chinaunix.net/thread-218853-1-1.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>網中人</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-01-13</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-01-13</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags"><i class="fa fa-tag"> </i><a class="link-muted mr-2" rel="tag" href="/tags/shell/">shell</a></div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://cdn.jsdelivr.net/gh/yhan219/blog-image@master/yhan/UMqd62.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://cdn.jsdelivr.net/gh/yhan219/blog-image@master/yhan/RpRzj9.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/soft-ether-vpn/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">SoftEther使用命令行搭建VPN服务器</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/idea-ssh-mysql/"><span class="level-item">DateGrip或Idea通过ssh连接数据库</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.2/gitalk.css"><script src="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.2/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "de317578243c09fdb8afd46a08a77fa7",
            repo: "blog-comment",
            owner: "yhan219",
            clientID: "eec4eb02a961237a2e21",
            clientSecret: "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",
            admin: ["yhan219"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://coding-net-production-static-ci.codehub.cn/a79d1f0e-bb39-4be8-afc5-99302615f944.jpg?imageMogr2/auto-orient/format/jpeg/cut/800x800x0x0" alt="yhan219"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">yhan219</p><p class="is-size-6 is-block">java web</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>云南, 中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">42</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">59</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yhan219" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#第1问：为何叫做shell？"><span class="level-left"><span class="level-item">1</span><span class="level-item">第1问：为何叫做shell？</span></span></a></li><li><a class="level is-mobile" href="#第2问：shell-prompt（PS1）与-Carriage-Return（CR）的关系？"><span class="level-left"><span class="level-item">2</span><span class="level-item">第2问：shell prompt（PS1）与 Carriage Return（CR）的关系？</span></span></a></li><li><a class="level is-mobile" href="#第3问：别人echo、你也echo，是问echo知多少？"><span class="level-left"><span class="level-item">3</span><span class="level-item">第3问：别人echo、你也echo，是问echo知多少？</span></span></a></li><li><a class="level is-mobile" href="#第4问：“”（双引号）与’’（单引号）差在哪？"><span class="level-left"><span class="level-item">4</span><span class="level-item">第4问：“”（双引号）与’’（单引号）差在哪？</span></span></a></li><li><a class="level is-mobile" href="#第5问：var-value-export前后差在哪"><span class="level-left"><span class="level-item">5</span><span class="level-item">第5问：var=value? export前后差在哪?</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#设定（set）"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">设定（set）</span></span></a></li><li><a class="level is-mobile" href="#变量替换（substitution）"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">变量替换（substitution）</span></span></a></li><li><a class="level is-mobile" href="#export"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">export</span></span></a></li><li><a class="level is-mobile" href="#取消变量"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">取消变量</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第6问：exec跟source差在哪？"><span class="level-left"><span class="level-item">6</span><span class="level-item">第6问：exec跟source差在哪？</span></span></a></li><li><a class="level is-mobile" href="#第7问：-与-差在哪？"><span class="level-left"><span class="level-item">7</span><span class="level-item">第7问：( ) 与 { } 差在哪？</span></span></a></li><li><a class="level is-mobile" href="#第8问：-与-与-还有-差在哪？"><span class="level-left"><span class="level-item">8</span><span class="level-item">第8问：(( )) 与(())与( ) 还有${ } 差在哪？</span></span></a></li><li><a class="level is-mobile" href="#第9问：-与-与-差在哪？"><span class="level-left"><span class="level-item">9</span><span class="level-item">第9问：@ 与@与* 差在哪？</span></span></a></li><li><a class="level is-mobile" href="#第10问：-amp-amp-与-差在哪？"><span class="level-left"><span class="level-item">10</span><span class="level-item">第10问：&amp;&amp; 与 || 差在哪？</span></span></a></li><li><a class="level is-mobile" href="#第11问：-gt-与-lt-差在哪？"><span class="level-left"><span class="level-item">11</span><span class="level-item">第11问：&gt; 与 &lt; 差在哪？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#11-1"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">11.1</span></span></a></li><li><a class="level is-mobile" href="#11-2"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">11.2</span></span></a></li><li><a class="level is-mobile" href="#11-3"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">11.3</span></span></a></li><li><a class="level is-mobile" href="#11-4"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">11.4</span></span></a></li><li><a class="level is-mobile" href="#11-5"><span class="level-left"><span class="level-item">11.5</span><span class="level-item">11.5</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第12问：你要-if-还是-case-呢？"><span class="level-left"><span class="level-item">12</span><span class="level-item">第12问：你要 if 还是 case 呢？</span></span></a></li><li><a class="level is-mobile" href="#第13问：for-what？while与until差在哪？"><span class="level-left"><span class="level-item">13</span><span class="level-item">第13问：for what？while与until差在哪？</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">学习</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T09:56:41.000Z">2022-03-16</time></p><p class="title"><a href="/smart-doc-torna/">smart-doc+torna搭建企业级接口管理系统</a></p><p class="categories"><a href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-15T01:59:21.000Z">2021-12-15</time></p><p class="title"><a href="/nginx-location/">一文理清nginx中的location配置</a></p><p class="categories"><a href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-10T01:59:21.000Z">2021-12-10</time></p><p class="title"><a href="/idea-active/">IDEA及付费插件激活(长期更新)</a></p><p class="categories"><a href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-31T07:37:54.000Z">2021-10-31</time></p><p class="title"><a href="/nc/">Linux nc命令</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-22T06:37:15.000Z">2021-09-22</time></p><p class="title"><a href="/arthas-hot-swap/">使用arthas修改代码并热交换</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/DateGrip/"><span class="tag">DateGrip</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Idea/"><span class="tag">Idea</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IntelliJ-IDEA/"><span class="tag">IntelliJ IDEA</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Jetbrains/"><span class="tag">Jetbrains</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VPN/"><span class="tag">VPN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/acme-sh/"><span class="tag">acme.sh</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/alfred/"><span class="tag">alfred</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/alpine/"><span class="tag">alpine</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/arthas/"><span class="tag">arthas</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bash/"><span class="tag">bash</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos/"><span class="tag">centos</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker-compose/"><span class="tag">docker compose</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gitea/"><span class="tag">gitea</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/http/"><span class="tag">http</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/https/"><span class="tag">https</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/idea/"><span class="tag">idea</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/navicat/"><span class="tag">navicat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rabbitmq/"><span class="tag">rabbitmq</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sdkman/"><span class="tag">sdkman</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/seaweedfs/"><span class="tag">seaweedfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/show-hosts/"><span class="tag">show hosts</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring-boot/"><span class="tag">spring boot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">ssh</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemctl/"><span class="tag">systemctl</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemd/"><span class="tag">systemd</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vpncmd/"><span class="tag">vpncmd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vps/"><span class="tag">vps</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/windows/"><span class="tag">windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/workflow/"><span class="tag">workflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xxl-job/"><span class="tag">xxl-job</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zookeeper/"><span class="tag">zookeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="tag">中间件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%91%E7%9B%98/"><span class="tag">云盘</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6/"><span class="tag">免费证书</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"><span class="tag">内网穿透</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><span class="tag">分布式锁</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4/"><span class="tag">命令</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="tag">命令行</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">小文件服务器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%B6%E5%8C%BA/"><span class="tag">时区</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%B6%E9%97%B4/"><span class="tag">时间</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="tag">消息队列</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BF%80%E6%B4%BB/"><span class="tag">激活</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B4%A2%E5%BC%95/"><span class="tag">索引</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%90%E7%BB%B4/"><span class="tag">运维</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81/"><span class="tag">锁</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"><span class="tag">问题排查</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://coding-net-production-static-ci.codehub.cn/a79d1f0e-bb39-4be8-afc5-99302615f944.jpg?imageMogr2/auto-orient/format/jpeg/cut/800x800x0x0" alt="yhan219" height="28"></a><p class="is-size-7"><span>&copy; 2018 - 2022 網中人</span>  版权所有<br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>